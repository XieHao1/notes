# 位运算相关面试题

Java的位运算主要有：按位与(`&`)、按位或(`|`)、按位取反(`~`)、按位异或(`^`)、左移(`<<`)、带符号右移(`>>`)、无符号右移(`>>>`)



## 1.按位与(&)

当相同位上的两个数字都为1时，结果为1；否则为0

```java
1&1=1 
1&0=0
0&1=0 
0&0=0 
```

## 2.按位或(|)

当相同位上的数字至少有一个为1时，结果为1；否则为0

```java
 1|1=1 
 1|0=1 
 0|1=1 
 0|0=0
```

## 3.按位取反(~)

```java
^1=0
^0=1
```

## 4.按位异或(^)

当相同位上的两个数字不同时，结果为1；相同时为0

```java
1^1=0 
1^0=1 
0^1=1 
0^0=0
```



## 5.左移(<<)

将二进制数字向左移动，移动几位就在最右侧补多少个0。
例如 `3<<1`，因为3的二进制表示形式为11，向左移动一位后变为110，所以 `3<<1=6`。
左移n位相当于乘上2的n次方。

## 6.带符号右移(>>)

将二进制数字向右移动，移动几位就在最右侧消去多少个比特位，并最左侧**`填充符号位`**。
例如 `3>>1`，因为3的二进制表示形式为011，所以向右移动一位后变为001，所以 `3>>1=1`。
例如 `-3>>1`，因为-3的二进制补码表示为11111111111111111111111111111101，所以带符号向右移动一位后变为11111111111111111111111111111110，对应的数字为-2，所以 `-3>>1=-2`。
1左移一位会变成0，0左移依旧为0。



## 7.无符号右移(>>>)

将二进制数字向右移动，移动几位就在最右侧消去多少个比特位，并最左侧填充0。
例如 `-3>>>1`，因为-3的二进制补码表示为11111111111111111111111111111101，所以无符号向右移动一位后变为01111111111111111111111111111110，对应的数字为2147483646，所以 `-3>>>1=2147483646`



## 8.原码，反码和补码

### 8.1 原码

**最高位是符号位，0代表正数，1代表负数，非符号位为改数字绝对值的二进制表示。**
（127的原码为0111 1111，-127的原码为1111 1111）

### 8.2 反码

**正数的反码与原码一致；负数的反码只是原码取反，符号位不变。**
（127的反码为0111 1111，-127的反码为1000 0000）

### 8.3 补码

**正数的补码与原码一样；负数的补码是该数的反码+1。**（127的补码为0111 1111，-127的补码为1000 0001）

注：还有一种求补码方法是负数的补码等于模减去该数的绝对值

补码的正0和负0只有一种表示方法（补码+0和-0表示出来都是8位00000000，所以**补码的表示范围整数比原码和反码多表示一个数**。

比如：8位（2的8次方），补码是-128~+127 原码和反码都是-127~+127



## 9.打印一个int的32位二进制数

```java
public class Test1 {
    //打印一个int的32位二进制
    private static void print(int num){
        for(int i = 31 ; i>=0 ; i-- ){
            System.out.print((num & (1 << i))== 0 ? "0" : "1");
            // num=1 => 00000000000000000000000000000001   1的二进制位
            //     1 => 00000000000000000000000000000001
            // 1<<31 => 10000000000000000000000000000000   1向左移动31位后的二进制位
            //        & 00000000000000000000000000000001   &操作，只有全是1才是1，其它为0
            //        -----------------------------------
            //          00000000000000000000000000000000
        }
        System.out.println();
    }

    public static void main(String[] args) {
        print(1);//00000000000000000000000000000001
    }
}

```





## 11.取一个数的相反数

**`原数取反+1`**

```java
    public static void main(String[] args) {
        int i = 5;
        //直接加-号
        System.out.println(-i);
        //取反加1
        System.out.println(~i+1);
        //  5的二进制 00000000000000000000000000000101
        //    ~1 => 11111111111111111111111111111010
        //      +1  11111111111111111111111111111011
        //转换为补码  10000000000000000000000000000101 => -5
```





## 12.异或相关面试题

　**异或是一种基于二进制的位运算，用符号XOR或者 ^ 表示，其运算法则是对运算符两侧数的每一个二进制位，`同值取0，异值取1`(不进位相加)。**

　　**性质**
　　　　**1、交换律**
　　　　**2、结合律（即(a^b)^c == a^(b^c)）**
　　　　**3、对于任何数x，都有x^x=0，x^0=x**
　　　　**4、自反性 A XOR B XOR B = A XOR 0 = A**



### 12.1 实现两个值的交换，而不必使用临时变量

```java
例如交换两个整数a = 10100001, b = 00000110的值， 可通过下列语句实现：

    a = a ^ b;            //a = 10100111

    b = b ^ a;            //b = 10100001 ==> b ^ a ^ b

    a = a ^ b;            //a =  00000110 ==> (a ^ b) ^ (b ^ a ^ b)
```



### 12.2 一个数组中有一种数出现了奇数次，其它的数都出现了偶数次。怎么找到打印这种数。

```java
        //一个数组中有一种数出现了奇数次，其它的数都出现了偶数次。怎么找到打印这种数。
        int[] arr = {1,2,1,3,1,3,4,1,2,4,4};
        //上面的数组中1出现4次,2出现2次，3出现2次，4出现3次
        int eor = 0;
        for (int i : arr) {
            eor = eor ^ i;
		 }
        //eor^1^2^1^3^1^3^4^1^2^4^4 ==> eor^1^1^1^1^2^2^3^3^4^4^4
        System.out.println(eor);//4
```



### 12.3 一个数组中有两种数出现了奇数次，其它的数都出现了偶数次。怎么找到打印这种数

```java
	   //一个数组中有两种数出现了奇数次，其它的数都出现了偶数次。怎么找到打印这种数
        //上面的数组中1出现4次,2出现2次，3出现2次，4出现3次,5出现5次
        int[] arr = {1,2,1,3,1,3,4,1,2,4,4,5,5,5,5,5};
        //1.将数组中的数^
        int eor = 0;
        for(int i : arr){
            eor ^= i;
        }
        //最后的结果一定为 4^5
        //4的二进制:0100 5的二进制:0101
        //^操作后: 0001
        
        //这时我们取出eor二进制最右边的1
        //这里eor的右边的1为0001-->在最后一位
        int rightOne = eor & (-eor);
        //此时我们可以把原数组中的数分成两类：数组中的二进制数和eor最右边的1在位置上相同，都为1，
        //比如:  满足条件的（二进制位最后一位是1）：1的二进制：0001,3的二进制：0011,5的二进制: 0101
        //     不满足条件的（二进制位最后一位是0）: 2的二进制：0010,4的二进制：0100

        //这样数组中的满足条件的两个数就分在了不同的组中
        //在对其中一组进行异或，取出其中一个值
        int one = 0;
        for (int i : arr) {
            if ((rightOne & i) != 0) {
                one ^= i; //取出5
            }
        }
        //再取出另外一个
        int two = rightOne ^ one;
```



### 12.4 一个数组中有一种数出现K次，其它的数都出现了M次。怎么找到打印这种数(M>1,K<M)。找到出现了K次的数。

要求,额外空间复杂度O(1),时间复杂度O(N)

#### 12.4.1 使用Map统计

使用该方式不满足额外空间复杂度O(1)

```java
    // 一个数组中有一种数出现K次，其它的数都出现了M次。怎么找到打印这种数(M>1,K<M)。找到出现了K次的数.
    public static int KM_map(int[] arr,int K,int M){
        //使用Map集合对数组中的数进行记录
        Map<Integer,Integer> map = new HashMap<>();
        for (int i : arr){
            //如果集合中包含了该元素，则次数+1
            if(map.containsKey(i)){
               map.put(i,map.get(i) +1 );
               //如果集合中没有该元素，则添加到集合中
            }else {
                map.put(i,1);
            }
        }
        //遍历集合
        for(Integer key : map.keySet()){
            if(map.get(key) == K){
                return key;
            }
        }
        return -1;
    }
```



#### 12.4.2 使用二进制位数组

```java
//一个数组中有一种数出现K次，其它的数都出现了M次。怎么找到打印这种数(M>1,K<M)。找到出现了K次的数.
    //要求,额外空间复杂度O(1),时间复杂度O(N)
    public static int KM(int[] arr,int K,int M){
        //将一个int的二进制位保存在int[]数组中
        int[] binaryArr = new int[32];//数组是定长的，空间复杂度为O(1)
        //将目标数组中的元素二进制位上出现1的进行累加
        for (int num : arr) {
            //取出元素的所有二进制位,如果是1，则相加
            for (int j = 0; j < 32; j++) {
                binaryArr[j] += (num >> j) & 1;
                //二进制中的数不是0就是1，所以之间累加即可
            }
        }
        //假设数字3(0011)和数字7(0111)出现了7次,数字5(0101)出现3次---->则binaryArr[0]的结果为7+7+3 = 17次
        //假设数字3(0011)和数字7(0111)出现了7次,数字4(0100)出现3次---->则binaryArr[0]的结果为7+7+0 = 14次
        // ==》可以发现，如果统计的次数是M的整数倍，说明出现K次的数在该位置上没有1，如果统计的次数不是M的整数倍，则对统计次数%M,得到的余数应该为K
        int answer = 0;
        for (int i = 0; i < 32; i++) {
            //统计的次数不是M的整数倍，则对统计次数%M,得到的余数应该为K
            // 则该位置上的数是是出现K次数在该位置上的二进制数或者是K，M共同在该位置上的二进制数。
          if(binaryArr[i] % M != 0){
            //将二进制数组元素恢复为原先的二进制数
              answer = answer | (1 << i);
          }
        }
        return answer;
    }
```

