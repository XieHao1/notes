# 正则表达式

java.util.regex 包主要包括以下三个类：

- `Pattern` 类：

  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

- `Matcher` 类：

  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

- `PatternSyntaxException`：

  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

## 1.实现原理

```java
 String content = "1998 年 12 月 8 日，第二代 Java 平台的企业版 J2EE 发布。1999 年 6 月，Sun 公司发布了" +
                "第二代 Java 平台（简称为 Java2）的 3 个版本：J2ME（Java2 Micro Edition，Java2 平台的微型" +
                "版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2 平台的" +
                "标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2 平台的企业版），应" +
                "用 3443 于基于 Java 的应用服务器。Java 2 平台的发布，是 Java 发展过程中最重要的一个" +
                "里程碑，标志着 Java 的应用开始普及 9889 ";
        // \\d表示任意一个数字
        Pattern pattern = Pattern.compile("\\d\\d\\d\\d");
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到:" + matcher.group(0));
        }
    }
```

group方法

```java
    public String group(int group) {
        if (first < 0)
            throw new IllegalStateException("No match found");
        if (group < 0 || group > groupCount())
            throw new IndexOutOfBoundsException("No group " + group);
        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
            return null;
        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
    }
```

### 1.1 未分组

>  Pattern pattern = Pattern.compile("\\\d\\\d\\\d\\\d");

**`matcher.find()`**:

1．根据指定的规则，定位满足规则的子字符串(比如1999)

2．找到后，将子字符串的开始的索引记录到matcher对象的属性 int[] `groups`;

   groups[0]=0，把该子字符串的结束的索引+1的值记录到groups[1] = 4

3，同时记录`oldLast`的值为子字符串的结束的索引+1的值即4，即下次执行find时，就从4开始匹配

![image-20230403151616096](img.assets\image-20230403151616096.png)

**`matcher.group(0)`**:

1．根据 groups[0]=0和 groups[1]=4 的记录的位置，从content开始截取子字符串返回,就是[0,4)包含0但是不包含索引为4的位置

如果再次指向find方法.仍然按上面分析来执行



### 1.2 分组

> Pattern pattern = Pattern.compile("(\\\d\\\d)(\\\d\\\d)");

什么是分组，比如 (\d\d)(\d\d) ,正则表达式中有`() 表示分组`,第 1 个()表示第 1 组,第 2 个()表示第 2 组...

**`matcher.find()`**:

1. 根据指定的规则 ,定位满足规则的子字符串(比如(19)(98))

2. 找到后，将字符串的开始的索引记录到 matcher 对象的属性 int[] `groups`;

    2.1 groups[0] = 0 , 把该子字符串的结束的索引+1 的值记录到 groups[1] = 4

​	2.2 记录 1 组()匹配到的字符串 groups[2] = 0,groups[3] = 2

​	2.3 记录 2 组()匹配到的字符串 groups[4] = 2,groups[5] = 4

​	2.4.如果有更多的分组..... 

3. 同时记录 `oldLast` 的值为子字符串的结束的索引+1 的值即4, 即下次执行 find 时，就从 4 开始匹配

![image-20230403152501965](img.assets\image-20230403152501965.png)

**`matcher.group(0)`**;**`matcher.group(1)`**;**`matcher.group(2)`**

1. 如果正则表达式有() 即分组,取出匹配的字符串规则如下
2. group(0) 表示匹配到的子字符串
3. group(1) 表示匹配到的子字符串的第一组字串
4. group(2) 表示匹配到的子字符串的第二组字串
5. ... 但是分组的数不能越界

```java
System.out.println("找到:" + matcher.group(0));
System.out.println("找到第一组:" + matcher.group(1));
System.out.println("找到第二组:" + matcher.group(2));
```



## 2.元字符

### 2.1 转义号\\\

\\\符号说明:在我们使用正则表达式去检索某些`特殊字符`的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， **n**匹配字符 **n**。**\n** 匹配换行符。序列 **\\\\** 匹配 **\\** ，**\\(** 匹配 **(**。

> 在Java的正则表达式中，两个\\\代表其他语言中的一个\

```java
 		String content = "abc$(123(23243($";
        //匹配(
        Pattern pattern = Pattern.compile("\\(");
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到:" + matcher.group(0));
        }
```

> 需要用到转义符号的字符有以下: . * + () $ / \ ? [] ^ {}



### 2.2 字符匹配符

| 符号 | 符号说明                                                     | 示例           | 解释                                                 | 输入匹配            |
| :--: | ------------------------------------------------------------ | -------------- | ---------------------------------------------------- | ------------------- |
|  []  | 可接收的字符列表                                             | [efgh]         | e.f.g.h中的任意一个字符                              |                     |
| [^]  | 不接收的字符列表                                             | [^abc]         | 除a.b.c之外的任意一个字符，包括数字和特殊符号        |                     |
|  -   | 连字符                                                       | A-Z            | 任意单个大写字母                                     |                     |
|  .   | 匹配除\n以外的任何字符                                       | a..b           | 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 | aaab,aefb,a35b,a#*b |
| \\\d | 匹配单个数字字符，相当于[0-9]                                | \\\d{3}(\\\d)? | 包含3个或4个数字的字符串                             | 123,9876            |
| \\\D | 匹配单个非数字字符，相当于\[^0-9]                            | \\\D(\\\d)*    | 以单个非数字字符开头，后接任意个数字字符串           | a,A342              |
| \\\w | 匹配单个数字、大小写字母字符和下划线，相当于[0-9a-zA-Z]      | \\\d{3}\\\w{4} | 以3个数字字符开头的长度为7的数字字母字符串           | 234abcd,12345pe     |
| \\\W | 匹配单个非数字、大小写字母字符和下划线，相当于\[^0-9a-zA-Z]  | \\\W+\\\d{2}   | 至少1个非数字字母字符开头,2个数字字符结尾的字符串    | #29,#?@10           |
| \\\s | 匹配任何空白字符，包括空格、制表符、换页符等。与 [\f\n\r\t\v] 等效。 |                |                                                      |                     |
| \\\S | 匹配任何非空白字符。与 \[^\f\n\r\t\v] 等效。                 |                |                                                      |                     |

> 匹配字符串**`不区分大小写`**

```java
String regExp = "(?i)abc";//匹配 abc 字符串[不区分大小写]
String regExp = "a(?i)bc"//表示bc不区分大小写
String regExp = "a((?i)b)c"//表示只有b不区分大小写
Pattern pattern = Pattern.compile(regExp,Pattern.CASE_INSENSITIVE); //不区分大小写匹配
```



### 2.3 选择匹配符

在匹配某个字符串的时候是选择性的

| 符号 | 符号说明                   | 示例   | 解释     |
| :--: | -------------------------- | ------ | -------- |
|  \|  | 匹配"\|"之前或之后的表达式 | ab\|cd | ab或者cd |



### 2.4  限定符

用于指定其前面的字符和组合项连续出现多少次

| 符号  | 符号说明                                             | 示例        | 解释                                              | 输入匹配            |
| :---: | ---------------------------------------------------- | ----------- | ------------------------------------------------- | ------------------- |
|   *   | 指定字符重复0次或n次(无要求)零到多,\* 等效于 {0,}    | (abc)*      | 仅包含任意个abc的字符串，等效于\\\w*              | abc,abcabcabc       |
|   +   | 指定字符重复1次或n次`(至少一次)`1到多,\+ 等效于 {1,} | m+(abc)*    | 以至少1个m开头，后面接任意个abc的字符串           | m,mabc,mmmabc       |
|   ?   | 指定字符重复0次或1次`(最多一次)`0到1,? 等效于 {0,1}  | m+abc?      | 以至少1个m开头，后接ab或者abc的字符串             | m,mab,mabc          |
|  {n}  | 只能输入n个字符                                      | [abcd]{3}   | 由abcd中字母组成的任意长度为3的字符串             | abc,bcd,adc         |
| {n,}  | 指定至少n个匹配                                      | [abcd]{3,}  | 由abcd中字母组成的任意长度不小于3的字符串         | aab,bdc,aaabcd      |
| {n,m} | 指定至少n个但不多于m个匹配                           | [abcd]{3,5} | 由abcd中字母组成的任意长度不小于3,不大于5的字符串 | abc,bdc,aaaaa,bcdab |

> JAVA匹配时默认为**`贪婪匹配`**,尽量匹配多的



### 2.5 定位符

定位符, 规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置

| 符号 | 符号说明               | 示例               | 解释                                                         | 输入匹配                  |
| :--: | ---------------------- | ------------------ | ------------------------------------------------------------ | ------------------------- |
|  ^   | 指定起始字符           | ^[0-9]+[a-z]*      | 以至少1个数字开头，后接任意个小写字母的字符串                | 123,6aa,55edf             |
|  $   | 指定结束字符           | ^[0-9]\\\\-[a-z]+$ | 以1个数字开头后接连字符“-”，并以至少1个小写字母结尾的字符串  | 1-a                       |
| \\\b | 匹配目标字符串的边界   | han\\\b            | 这里说的字符串的边界指的是子串间有`空格`，或者是自标字符串的`结束位置` | hanhan<br>sp`han` nn`han` |
| \\\B | 匹配目标字符串的非边界 | han\\\B            | 和\\\b的含义刚刚相反                                         | `hanhan`<br/>sphan nnhan  |



### 2.6 捕获分组

| 常用分组构成形式 | 说明                                                         |
| :--------------: | ------------------------------------------------------------ |
|    (pattern)     | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 |
| (?<name>pattren) | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如(?'name') |

```java
		Pattern pattern = Pattern.compile("(?<g1>\\d\\d)(?<g2>\\d\\d)");
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            //通过组名获取分组
            System.out.println("找到:" + matcher.group(0));
            System.out.println("找到第一组:" + matcher.group("g1"));
            System.out.println("找到第二组:" + matcher.group("g2"));
        }
```



### 2.7 非捕获分组

| 常用分组构成形式 | 说明                                                         |
| :--------------: | ------------------------------------------------------------ |
|   (?:pattren)    | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符(\|)组合模式部件的情况很有用。例如,'industr(?:y\|ies)是比'industry\|industries'更经济的表达式。 |
|   (?=pattren)    | 它是一个非捕获匹配。例如，'Windows (?=95[98[NT\|2000)'匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。 |
|   (?!pattren)    | 该表达式匹配不处于匹配 pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，'Windows (?!95[98[NT2000)'匹配"Windows 3.1"中的“Windows"，但不匹配"Windows 2000"中的"Windows"。 |

```java
String content = "hello 韩顺平教育 jack 韩顺平老师 韩顺平同学 hello 韩顺平学生";
// 找到 韩顺平教育 、韩顺平老师、韩顺平同学 子字符串
//String regStr = "韩顺平教育|韩顺平老师|韩顺平同学";
//上面的写法可以等价非捕获分组, 注意：不能 matcher.group(1)
String regStr = "韩顺平(?:教育|老师|同学)";
```

>(?=pattren)

```java
//找到 韩顺平 这个关键字,但是要求只是查找韩顺平教育和 韩顺平老师 中包含有的韩顺平
//下面也是非捕获分组，不能使用 matcher.group(1)
String regStr = "韩顺平(?=教育|老师)";
```

> (?!pattren)

```java
//找到 韩顺平 这个关键字,但是要求只是查找 不是 (韩顺平教育 和 韩顺平老师) 中包含有的韩顺平
//下面也是非捕获分组，不能使用 matcher.group(1)
String regStr = "韩顺平(?!教育|老师)";
```



### 2.8 非贪心模式

| 符号 | 符号说明                                                     |
| :--: | ------------------------------------------------------------ |
|  ?   | 当此字符紧随任何其他`限定符`（**、+、?、{*n*}、{*n*,}、{*n*,*m*}）`之后`时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o" |



## 3.反向引用

1. **`分组`**
   我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。

2. **`捕获`**

   把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志,第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式。

3. **`反向引用`**

   圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用,这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用**`\\分组号`**，外部反向引用**`$分组号`**

> 反向引用的使用

1.要匹配两个连续的相同数字

```java
String regExp = "(//d)//1";
```

2.要匹配五个连续的相同数字

```java
String regExp = "(//d)//1{4}";
```

3.要匹配个位与千位相同，十位与百位相同的数5225，1551

```java
String regExp = "(//d)(//d)//2//1";
```

4.把类似 : "我....我要....学学学学....编程 java!",通过正则表达式 修改成 "我要学编程 java"

```java
        String content = "我....我要....学学学学....编程java!";
        //将.替换成“”
        content = Pattern.compile("\\.").matcher(content).replaceAll("");
        //$1 外部引用，将第一个分组进行替换。比如用“我”-->代替"我我"
        content = Pattern.compile("(.)\\1+").matcher(content).replaceAll("$1");
        System.out.println(content);
```

