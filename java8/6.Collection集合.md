# Collection集合

Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collection`接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。对于`Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。

> Collection接口主要继承派生关系

![image-20230404171826166](img.assets\image-20230404171826166.png)

> Map接口主要继承派生关系

![image-20230404171924635](img.assets\image-20230404171924635.png)



`List`: 存储的元素是有序的、可重复的。

`Set`: 存储的元素是无序的、不可重复的。

`Queue`: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。

`Map`: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

## 1.Collection

```java
public interface Collection<E> extends Iterable<E>
```

1.collection实现子类可以存放多个元素，每个元素可以是Object

2.有些Collection的实现类,可以存放重复的元素，有些不可以

3.有些Collection的实现类，有些是有序的(List)，有些不是有序(Set)

4.Collection接口没有直接的实现子类，是通过它的子接口Set 和 List来实现的

> `Collection` 接口下面的集合。

 **`List:`**

- `ArrayList`： `Object[]` 数组
- `Vector`：`Object[]` 数组
- `LinkedList`： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

**`Set:`**

- `HashSet`(无序，唯一): 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素
- `LinkedHashSet`: `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。有点类似于我们之前说的 `LinkedHashMap` 其内部是基于 `HashMap` 实现一样，不过还是有一点点区别的
- `TreeSet`(有序，唯一): 红黑树(自平衡的排序二叉树)

 **`Queue:`**

- `PriorityQueue`: `Object[]` 数组来实现二叉堆
- `ArrayQueue`: `Object[]` 数组 + 双指针



### Collection中的常用方法

1) add():添加单个元素
2) remove():删除指定元素
3) contains():查找元素是否存在
4) size():获取元素个数
5) isEmpty():判断是否为空
6) clear():清空
7) addAll():添加多个元素
8) containsAll():查找多个元素是否都存在
9)  removeAll():删除多个元素



## 2.Iterable迭代器

```java
public interface Iterable<T>
```

1) Iterator对象称为迭代器，主要用于遍历 Collection集合中的元素。
2) 所有实现了Collection接口的集合类都有一个`iterator()`方法，用以返叵一个实现了lterator接口的对象,即可以返回一个迭代器。
3) lterator仅用于遍历集合,lterator本身并不存放对象。



`public Iterator iterator()`: 获取集合对应的迭代器，用来遍历集合中的元素的。

* **迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

Iterator接口的常用方法如下：

* `public E next()`:返回迭代的下一个元素。
* `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。

> 1. 在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。
> 2. 在进行集合元素获取时，如果`添加或移除集合中的元素, 将无法继续迭代`,将会抛出ConcurrentModificationException并发修改异常,若要删除，则使用`iterator.remove()`迭代器中的删除方法;
> 3. 如果需要重新迭代，则需要重新获取迭代器

Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素

![迭代器原理图](img.assets\迭代器原理图.bmp)

在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。



## 3.增强for

```java
        for (String next : list) {
            System.out.println(next);
        }
```

增强for循环底层是调用的`Iterator迭代器`

![image-20230404213118612](img.assets\image-20230404213118612.png)



## 4.List接口

`java.util.List`接口继承自`Collection`接口，是单列集合的一个重要分支，习惯性地会将实现了`List`接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素**`有序，即元素的存入顺序和取出顺序一致`。**

> List集合特点

1. 它是一个元素`存取有序`的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。
2. 它是一个`带有索引`的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
3. 集合中`可以有重复的元素`，通过元素的equals方法，来比较是否为重复的元素。

### 4.1 List集合中的常用方法

List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：

- `void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。
- `boolean addAll(int index, Collection<? extends E> c)`:从 index 位置开始将 eles 中的所有元素添加进来
- `E get(int index)`:返回集合中指定位置的元素。
- `E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。
- `E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
- `int indexOf(Object o)`;返回 o 在集合中首次出现的位置
- `int lastIndexOf(Object o)`;返回 o 在当前集合中末次出现的位置
- `E set(int index, E element)`;设置指定 index 位置的元素为 ele , 相当于是替换
- `List<E> subList(int fromIndex, int toIndex)`;返回从 fromIndex 到 toIndex 位置的子集合,注意返回的子集合 		   fromIndex <= subList < toIndex



### 4.2 ArrayList集合

`java.util.ArrayList`集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以`ArrayList`是最常用的集合。

permits all elements, including null ,`ArrayList可以加入null,并且多个`

ArrayList基本等同于Vector,除了ArrayList是`线程不安全`(执行效率高)。在多线程情况下，不建议使用ArrayList

---

`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用`ensureCapacity`操作来增加 `ArrayList` 实例的容量。这可以减少递增式再分配的数量。

`ArrayList`继承于 **`AbstractList`** ，实现了 **`List`**, **`RandomAccess`**, **`Cloneable`**, **`java.io.Serializable`** 这些接口。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

- `RandomAccess` 是一个标志接口，表明实现这个接口的 List 集合是支持**快速随机访问**的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。

- `ArrayList` 实现了 **`Cloneable` 接口** ，即覆盖了函数`clone()`，能被克隆。

- `ArrayList` 实现了 `java.io.Serializable`接口，这意味着`ArrayList`支持序列化，能通过序列化去传输。



#### 4.2.1 ArraysList扩容机制

##### 4.2.1.1 构造方法(JDK 11)

**（JDK11）ArrayList 有三种方式来初始化，构造方法源码如下：**

```java
	//默认初始容量大小
	private static final int DEFAULT_CAPACITY = 10;

	//空数组（用于空实例）
    private static final Object[] EMPTY_ELEMENTDATA = {};

	//用于默认大小空实例的共享空数组实例。
    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
	
	//保存ArrayList数据的数组 transient：被transient修改的变量不能序列化
    transient Object[] elementData; 

	// ArrayList 所包含的元素个数
    private int size;

	//初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            //如果传入的参数大于0，创建initialCapacity大小的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //如果传入的参数等于0，创建空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //其他情况，抛出异常
            throw new IllegalArgumentException("Illegal Capacity: "+  initialCapacity);
        }
    }

    /**
     *默认无参构造函数
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
	
    /**
     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
     */
    public ArrayList(Collection<? extends E> c) {
		//将指定集合转换为数组
        Object[] a = c.toArray();
        //如果a数组的长度不为0
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                elementData = a;
            } else {
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
             // 其他情况，用空数组代替
            elementData = EMPTY_ELEMENTDATA;
        }
    }
```

**以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。**

> JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 

##### 4.2.1.2 add()方法

```java
   //将指定的元素追加到此列表的末尾。
	public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
    }
    
    private void add(E e, Object[] elementData, int s) {
		//如果ArrayList包含的元素个数和elementData保存数组相同，则进行扩容
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
```

> JDK11 移除了 `ensureCapacityInternal()` 和 `ensureExplicitCapacity()` 方法



##### 4.2.1.3 grow()方法

```java
    private Object[] grow() {
        //ArrayList包含元素个数+1
        return grow(size + 1);
    }
```

```java
    private Object[] grow(int minCapacity) {
        //调用Arrays.copyOf()方法进行扩容
        return elementData = Arrays.copyOf(elementData,newCapacity(minCapacity));
    }
```



##### 4.2.1.4 newCapacity()方法

```java
    private int newCapacity(int minCapacity) {
        // oldCapacity为旧容量
        int oldCapacity = elementData.length;
        //newCapacity为新容量
        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
        int newCapacity = oldCapacity + (oldCapacity >> 1);
		//然后检查新容量是否大于最小需要容量
        if (newCapacity - minCapacity <= 0) {
            //如果使用默认的构造函数创建的elementData
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                //返回DEFAULT_CAPACITY = 10，和minCapacity（第一次是1）的最大值
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        }
        // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
        //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 	
        //`Integer.MAX_VALUE - 8`。
        return (newCapacity - MAX_ARRAY_SIZE <= 0)? newCapacity : hugeCapacity(minCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        //对minCapacity和MAX_ARRAY_SIZE进行比较
        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小
        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小
        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
    }
```

**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！** 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。

> ">>"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity / 2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源

##### 4.2.1.5 ensureCapacity()方法

```java
    //有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
	public void ensureCapacity(int minCapacity) {
        if (minCapacity > elementData.length
            && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA && minCapacity <= DEFAULT_CAPACITY)) {
            modCount++;
            grow(minCapacity);
        }
    }
```



#### 4.2.2 length,length(),size()

java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.

java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.

java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!



#### 4.2.3 `System.arraycopy()` 和 `Arrays.copyOf()`方法

阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法

**`System.arraycopy()` 方法**

```java
	// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义
    /**
    *   复制数组
    * @param src 源数组
    * @param srcPos 源数组中的起始位置
    * @param dest 目标数组
    * @param destPos 目标数组中的起始位置
    * @param length 要复制的数组元素的数量
    */
    public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);
```

**`Arrays.copyOf()`方法**

```java
    public static <T> T[] copyOf(T[] original, int newLength) {
        return (T[]) copyOf(original, newLength, original.getClass());
    }

	@HotSpotIntrinsicCandidate
    public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
        @SuppressWarnings("unchecked")
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
        return copy;
    }
```



#### 4.2.4 modCount属性

在ArrayList,LinkedList,HashMap等等的内部实现增，删，改中我们总能看到modCount的身影，modCount字面意思就是修改次数,所有使用modCount属性的全是`线程不安全`的,只有在本数据结构对应迭代器中才使用

```java
 int expectedModCount = modCount;
//ArrayList迭代器内部类中的checkForComodification检查这个对象的modCount和迭代器中存储的modCount是否一致
 final void checkForComodification() {
   if (modCount != expectedModCount)
      throw new ConcurrentModificationException();
 }
```

> **Fail-Fast 机制**

我们知道Java中Collection接口下的很多集合都是线程不安全的, 比如 java.util.ArrayList不是线程安全的, 因此如果在使用迭代器的过程中有其他线程修改了list，那么将抛出ConcurrentModificationException，这就是所谓`fail-fast`策略。

#### 4.2.5  Arraylist和Vector的区别

1. `ArrayList` 是 `List` 的主要实现类，底层使用 `Object[ ]`存储，适用于频繁的查找工作，线程不安全 ；

2. `Vector` 是 `List` 的古老实现类，底层使用 `Object[ ]`存储，线程安全的



#### 4.2.6 Arraylist与LinkedList区别

- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）
- 插入和删除是否受元素位置的影响：
  - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
  - `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。
- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
- **内存空间占用：** `ArrayList`的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。

> 我们在项目中一般是不会使用到 `LinkedList` 的，需要用到 `LinkedList` 的场景几乎都可以使用 `ArrayList` 来代替，并且，性能通常会更好
>
> 不要认为 `LinkedList` 作为链表就最适合元素增删的场景。`LinkedList` 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 



### 4.3 Vector集合

Vector是线程同步的，即线程安全, Vector类的操作方法带有`synchronized`

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

> 属性

```java
    //Vector保元素集合
	protected Object[] elementData;

	//此Vector对象中有效组件的数量
    protected int elementCount;

	//容量自动增加的量,则每次需要增长时，容量都会加倍。如果不设置，则默认为0
    protected int capacityIncrement;
```

#### 4.3.1 构造函数(JDK 11)

```java
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }

    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
	
	//默认创建一个长度为10的Object数组
    public Vector() {
        this(10);
    }
    
    public Vector(Collection<? extends E> c) {
        Object[] a = c.toArray();
        elementCount = a.length;
        if (c.getClass() == ArrayList.class) {
            elementData = a;
        } else {
            elementData = Arrays.copyOf(a, elementCount, Object[].class);
        }
    }
```

#### 4.3.2 newCapacity()方法

```java
    private int newCapacity(int minCapacity) {
        int oldCapacity = elementData.length;
		//如果不设置。capacityIncrement = 0 ;
        //在不设置capacityIncrement的情况下，默认扩容为原来的2倍
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity <= 0) {
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
    }
```



### 4.4 LinkedList集合

`java.util.LinkedList`集合数据存储的结构是链表结构。方便元素添加、删除的集合。

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
    //LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
```

> LinkedList底层实现了双向链表和双端队列特点(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

![双向链表](img.assets\双向链表.png)

实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法作为**了解即可**：

- `public void addFirst(E e)`:将指定元素插入此列表的开头。
- `public void addLast(E e)`:将指定元素添加到此列表的结尾。
- `public E getFirst()`:返回此列表的第一个元素。
- `public E getLast()`:返回此列表的最后一个元素。
- `public E removeFirst()`:移除并返回此列表的第一个元素。
- `public E removeLast()`:移除并返回此列表的最后一个元素。
- `public E pop()`:从此列表所表示的堆栈处弹出一个元素。
- `public void push(E e)`:将元素推入此列表所表示的堆栈。
- `public boolean isEmpty()`：如果列表不包含元素，则返回true。



#### 4.4.1 构造函数

```java
// 元素个数
transient int size = 0;

/**
指向第一个节点的指针
不变性:
1. 如果first = null，则last=null
2. 如果first.prev == null，则first.item != null
*/
transient Node<E> first;

/**
指向最后一个节点的指针
不变性:
1. 如果first = null，则last = null
2. 如果last.next == null，则last.item != null
*/
transient Node<E> last;

public LinkedList() {}

public LinkedList(Collection<? extends E> c) {
    this();
    addAll(c);
}
```



#### 4.4.2 双向链表

```java
    private static class Node<E> {
        E item;
        Node<E> next;// 下一个Node的引用
        Node<E> prev;// 上一个Node的引用

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```



#### 4.4.3 添加实现

##### 4.4.3.1 add()方法

```java
    public boolean add(E e) {
        //将指定的元素附加到此列表的末尾
        linkLast(e);
        return true;
    }
```

##### 4.4.3.2 linkLast() 方法

```java
    void linkLast(E e) {
        //指向当前链表的最后一个对象,即添加新节点的上一个节点对象
        final Node<E> l = last;
        //下一个对象的prev指向当前链表中的最后一个对象
        final Node<E> newNode = new Node<>(l, e, null);
		//last指向新创建的node对象
        last = newNode;
		//如果当前链表的最后一个对象是null,则说明是添加的第一个对象
        if (l == null)
            //当前链表的第一个对象指向node
            //即第一次添加时，first,last,l都指向第一个节点
            first = newNode;
		//如果最后一个对象不为null，而是指向一个节点
        else
            //则该节点的next指向新创建节点
            l.next = newNode;
        size++;
        modCount++;
    }
```

- 第一次添加first和last都指向第一个node节点

  ![image-20230406210434688](img.assets\image-20230406210434688.png)

- 第二次添加，first指向node1,last指向node2

![image-20230406211347851](img.assets\image-20230406211347851.png)



#### 4.4.4 删除实现

remove()方法默认删除第一个

##### 4.4.4.1 removeLast()方法

```java
    public E removeLast() {
        //获取最后一个节点对象
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }
```

##### 4.4.4.2 unlinkLast()方法

```java
    private E unlinkLast(Node<E> l) {
        //获取最后一个节点保存的元素
        final E element = l.item;
		//获取最后一个节点保存的前一个节点对象
        final Node<E> prev = l.prev;
		//将最后一个节点的元素修改为null
        l.item = null;
		//将最后一个节点指向的前一个节点修改为null
		//最后一个节点所有元素都为null，等待GC垃圾回收处理
        l.prev = null; // help GC
		//将最后一个节点的前一个节点设置为最后一个节点
        last = prev;
		//如果为null,说明删除的是第一个节点
        if (prev == null)
			//头节点指向null
            first = null;
        else
			//上一个节点的最后一个节点指向null
            prev.next = null;
        size--;
        modCount++;
        return element;
    }
```

##### 4.4.4.3 remove(Obejct o)方法

```java
    public boolean remove(Object o) {
        if (o == null) {
            //遍历链表，从first开始遍历，直到下一个节点的next!=null
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }
```

##### 4.4.4.4 unlink(Node<E> x)

```java
    E unlink(Node<E> x) {
        //获取该节点元素
        final E element = x.item;
        //获取该节点的下一个节点
        final Node<E> next = x.next;
        //获取该节点的上一个节点
        final Node<E> prev = x.prev;
		//如果该元素的上一个节点是null，则说明是第一个节点
        if (prev == null) {
             //first指向下一个节点
            first = next;
        } else {
            //上一个节点的next指向下一个节点
            prev.next = next;
            //该节点的prev=null
            x.prev = null;
        }
		//如果该元素的下一个节点是null,则说明是最后一个节点
        if (next == null) {
            //last指向上一个节点
            last = prev;
        } else {
            //下一个节点的perv指向上一个节点
            next.prev = prev;
            x.next = null;
        }
        x.item = null;
        size--;
        modCount++;
        return element;
    }
```



## 5.Set接口

java.util.Set`接口和`java.util.List`接口一样，同样继承自`Collection`接口，它与`Collection`接口中的方法基本一致，并没有对`Collection`接口进行功能上的扩充，只是比`Collection`接口更加严格了。与`List接口不同的是，Set接口都会以某种规则保证存入的元素不出现重复。

`Set`集合有多个子类，如`java.util.HashSet`、`java.util.LinkedHashSet`、`java.util.TreeSet`。

```java
public interface Set<E> extends Collection<E> 
```

> - set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, `可以添加一个null`
>
> - set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)
>
> - 注意：取出的顺序的顺序虽然不是添加的顺序，但是他是有固定的顺序。

常用方法:

- add(element): 向Set集合中添加一个元素。如果该元素已经存在于Set集合中，则添加操作将被忽略。

- remove(element): 从Set集合中移除指定的元素。

- contains(element): 检查Set集合中是否包含指定的元素，如果包含则返回true，否则返回false。

- size(): 返回Set集合中元素的个数。

- isEmpty(): 检查Set集合是否为空，如果为空则返回true，否则返回false。

- clear(): 清空Set集合中的所有元素。

- iterator(): 返回一个用于迭代Set集合中元素的迭代器



### 5.1  HashSet集合

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable
```

`java.util.HashSet`是`Set`接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。`java.util.HashSet`底层的实现其实是一个`java.util.HashMap`支持

`HashSet`是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：**`hashCode`**与**`equals`**方法。



#### 5.1.1 构造函数

```java
    //创建一个空的HashSet对象，不带任何参数
	public HashSet() {
        map = new HashMap<>();
    }
    //HashSet(Collection<? extends E> c): 创建一个新的HashSet对象，并将指定集合c中的所有元素添加到新的HashSet对象中
     public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
	//创建建一个具有指定初始容量和负载因子的HashSet对象。负载因子用于控制HashSet在填充程度达到多少时进行扩容操作
	  public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    }
	//创建一个具有指定初始容量的HashSet对象
    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }
	//给LinkedHashSet使用
	 HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
```



#### 5.1.2 HashSet存储数据的结构（哈希表）

在**JDK1.8**之前，哈希表底层采用数组+链表实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而`JDK1.8`中，哈希表存储采用**`数组+单向链表+红黑树`**实现，当**`链表长度超过阈值（8），并且数组的长度>=64`**时，将链表转换为红黑树，这样大大减少了查找时间。

简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。

![哈希表](img.assets\哈希表.png)

#### 5.1.3 执行add()方法

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
    //PRESENT作为HashMap中的value,只用于占位作用
    return map.put(e, PRESENT)==null;
}
```



```java
    public V put(K key, V value) {
        //hash(key) 计算hash值
        return putVal(hash(key), key, value, false, true);
    }

```



##### 5.1.3.1 hash(key)

```java
    static final int hash(Object key) {
        int h;
        /**
         这段代码是用于计算哈希值的一种常见方式，通常在哈希表的实现中使用。
         在计算哈希值时，将哈希码 h 右移 16 位的目的是为了增加哈希值的随机性，从而减小哈希冲突的概率。
         
         在哈希表中，哈希值的分布均匀性对于性能和效率至关重要。如果哈希值分布不均匀，会导致哈希表中某些槽位（buckets）存放了大量的		  元素，而其他槽位却没有元素，从而导致哈希表的性能下降，查询和插入操作的效率降低。
         
         通过将哈希码右移 16 位，并将高位的 16 位移动到低位，可以使哈希码的高位和低位进行异或操作，从而增加哈希值的随机性，使得哈希          值在哈希表中更均匀地分布。这样可以减小哈希冲突的概率，提高哈希表的性能和效率
        */
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```



##### 5.1.3.2 putVal方法

```java
	//HashMap数组默认长度16
	static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
	
	//数组最大容量，即 2 的 30 次方，等于 1073741824，用于限制哈希表的最大容量。这是因为哈希表的容量必须是 2 的整数次幂，这样才能  	//保证哈希值与槽位索引的计算能够高效地利用位运算，同时也能够保证哈希值的均匀分布
    static final int MAXIMUM_CAPACITY = 1 << 30;
	
	/**默认加载因子,加载因子是哈希表用来控制哈希冲突的一个参数。它表示哈希表在达到多少填充程度时会触发扩容操作。加载因子的值越大，哈		 希表的填充程度越高，触发扩容的频率越低；反之，加载因子的值越小，哈希表的填充程度越低，触发扩容的频率越高。
	
	  在 HashMap 和 HashSet 中，默认的加载因子为 0.75，这是一个经验性的设定，可以在提供较好的性能和空间效率之间做一个折中。较高	    的加载因子可以减少哈希冲突，提高查询性能，但同时也会增加哈希表的空间消耗；较低的加载因子可以减少空间消耗，但可能导致哈希冲突较	       多，降低查询性能*/
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
	
	//REEIFY_THRESHOLD 是 HashMap 和 HashSet 中触发红黑树转换的阈值，默认值为 8，链表长度>8时，转换为红黑树
    static final int TREEIFY_THRESHOLD = 8;

	//UNTREEIFY_THRESHOLD是HashMap和HashSet中触发将红黑树转换回链表的阈值，默认值为6。红黑树节点数小于等于6时，转换为链表
    static final int UNTREEIFY_THRESHOLD = 6;
	
	//HashMap 和 HashSet 中触发将链表转换成红黑树的最小桶容量阈值，默认值为64。在 HashMap 和 HashSet 中，当某个桶中的节点数超	//过MIN_TREEIFY_CAPACITY时，并且总桶数大于等于TREEIFY_THRESHOLD，会触发将链表转换成红黑树，以提高查找、插入、删除等操作的	//性能
    static final int MIN_TREEIFY_CAPACITY = 64;
	
	//Node数组
	transient Node<K,V>[] table;

//hash：键值 key 的哈希值
//key：要插入的键
//value：要插入的值
//onlyIfAbsent：是否只在键不存在时才插入,onlyIfAbsent 参数为 true，表示只在键不存在时才插入，那么在存在相同键的情况下，不会进行				值的更新
//evict：是否执行驱逐操作,evict 参数为 true，表示需要执行驱逐操作，一般在 LinkedHashMap 中使用，用于删除最老的节点
putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)
```

---

```java
 		//辅助变量
		Node<K,V>[] tab; Node<K,V> p; int n, i;
		//第一次加入，table = null
        if ((tab = table) == null || (n = tab.length) == 0)
            //第一次初始化数组,获取数组长度
            n = (tab = resize()).length;
		//计算数组下标，(n - 1) & hash 的结果是一个在 0 到 n-1 范围内的整数，作为数组的索引。
		//如果该数组下标有元素，不为null，则不执行
        if ((p = tab[i = (n - 1) & hash]) == null)
            //将该下标放入节点
            tab[i] = newNode(hash, key, value, null);
        else {
            //定义两个零时变量，保存节点和节点的key
            Node<K,V> e; K k;
            //p第一次指向数组指定下标中第一个node节点，如果该节点中的hash值与传入的hash值相同并且key相同或者key的equals方法比			  //较后相同（说明是对象相同或者对象中的内容相同）,则将p赋值给e
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
			//如果第一个节点不是链表，是一个红黑树，则按照红黑树的比较方式进行添加
            else if (p instanceof TreeNode)
                //传入当前map对象，当前node数组副本，哈希值，key和value
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            //如果都不是，则变量该数组下标下的链表，进行比较添加
            else {
                //死循环变量链表
                for (int binCount = 0; ; ++binCount) {
                    //e指向是下一个节点，如果下一个节点是null，则说明已经到最后一个节点，则直接加入
                    if ((e = p.next) == null) {
						//在最后添加一个节点
                        p.next = newNode(hash, key, value, null);
                      //如果该链表的元素个数>=8(从0开始),则将其转换为红黑树，但是如果数组的长度<64,则不会进行转换，而是进行扩容
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
						//结束循环
                        break;
                    }
					//如果下一个节点的哈希值与传入的哈希值相同，并且对象相同或者对象中的内容相同，则直接结束该方法
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
					//p指向下一个节点
                    p = e;
                }
            }
            //如果e的值不是null，说明链表中存在与传入的key相同的key，进行替换
            if (e != null) { // existing mapping for key
				//去处原理节点中的元素
                V oldValue = e.value;
                //onlyIfAbsent：是否只在键不存在时才插，默认为fales
                if (!onlyIfAbsent || oldValue == null)
					//替换元素
                    e.value = value;
				//执行替换后的操作，一般是由HashMap的子类LikedHashMap使用
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
		//如果元素个数>扩容阈值，则进行扩容
        if (++size > threshold)
            resize();
		//一个空方法。在 HashMap 和 HashSet 中都是用于在插入新节点后执行一些后续操作，包括更新状态、检查是否需要扩容等，主要被		 //HashMap的子类LikedHashMap使用
        afterNodeInsertion(evict);
        return null;
```



##### 5.1.3.3 resize()方法

```java
/**
	resize() 方法是 HashMap 和 HashSet 中用于扩容的方法。当 HashMap 或 HashSet 中的元素数量超过了当前容量与加载因子的乘积时，会触发扩容操作。
	resize() 方法的主要功能是创建一个新的数组，将原始数组中的元素重新分配到新数组中，并更新桶的索引位置，从而实现扩容。
	*/
final Node<K,V>[] resize() {
    	//保存老的数组
        Node<K,V>[] oldTab = table;
    	//获取老数组的长度,第一次加入时oldTab = null
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
    	//threshold 是HashMap 和HashSet中的一个属性，表示在进行扩容操作时，当元素的数量超过这个阈值时，会触发扩容
    	//第一次是0
        int oldThr = threshold;
    	//定义新的容量和扩容阈值
        int newCap, newThr = 0;
    	//如果老数组的长度>0
        if (oldCap > 0) {
			//如果老数组的长度>=64
            if (oldCap >= MAXIMUM_CAPACITY) {
				//threshold扩容阈值 = int的最大值
                threshold = Integer.MAX_VALUE;
				//返回老数组长度
                return oldTab;
            }
			//否则，数组长度扩容为原来的两倍，如果扩容两倍后的长度<64并且老数组长度>=16
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
                //扩容阈值增大两倍
                newThr = oldThr << 1; // double threshold
        }
    	//如果老扩容阈值>0
        else if (oldThr > 0) // initial capacity was placed in threshold
            //新数组长度 = 老扩容阈值
            newCap = oldThr;
    	//第一次是0时执行该方法
        else {               // zero initial threshold signifies using defaults
            //新数组的容量是默认值16
            newCap = DEFAULT_INITIAL_CAPACITY;
            //扩容阈值为0.75*16 = 12
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
    	//如果新的扩容阈值 == 0；
        if (newThr == 0) {
            //新数组长度*加载因子
            float ft = (float)newCap * loadFactor;
            //新的扩容阈值
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
    	//扩容阈值
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
    	//定义一个长度为16的node数组，并且赋值給table
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
    	//如果老数组不是null，则进行复制
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    //如果该链表上只有一个元素
                    if (e.next == null)
                        //重新计算数组下标存入原链表
                        newTab[e.hash & (newCap - 1)] = e;
                    //如果该链表是一颗红黑树,则替换为红黑树的方法
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    //如果都不是，则进行复制
                    else { // preserve order
                        //低位链表的头节点和尾节点，用于构建低位链表
                        Node<K,V> loHead = null, loTail = null;
                        //高位链表的头节点和尾节点，用于构建高位链表
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            //得到节点在旧容量下的位置索引
                            //哈希表的容量是 2 的幂次方的情况下，e.hash & (oldCap - 1) 的结果等价于 e.hash % oldCap，即							   //对节点的哈希值取模旧容量，
                            
                            //在旧容量下的位置索引是否为0，即节点的哈希值在二进制位上是否与旧容量的最高位相同。如果为0，表示节							   //点在旧容量下的位置索引位于低位，就将节点添加到低位链表中；否则，表示节点在旧容量下的位置索引位于							 //高位，就将节点添加到高位链表中。
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                //第一次头尾节点指向第一个元素
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else                            
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```



##### 5.1.3.4 添加原理图

![哈希流程图](img.assets\哈希流程图.png)

### 5.2 LinkedHashSet集合

在HashSet下面有一个子类`java.util.LinkedHashSet`，底层是一个`LinkedHashMap`,它是**`双向链表和哈希表`**组合的一个数据存储结构。

```java
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {
```

LinkedHashSet根据元素的hashCode值来决定元素的存储位置,同时使用链表维护元素的`次序`(图)，这使得元素看起来是以插入顺序保存的。

LinkedHashSet 通过维护一个双向链表来保证存储有序。在双向链表中，**每个节点都包含了指向前一个节点和后一个节点的引用**。当元素被插入到 LinkedHashSet中时，它会被同时添加到哈希表和双向链表中。哈希表用于实现快速的元素查找和删除，而双向链表则用于维护元素的插入顺序

![image-20230410161611897](img.assets\image-20230410161611897.png)

#### 5.2.1 构造函数

```java
   //定义初始容量和加载因子
	public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }
    //定义初始容量
    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }

	public LinkedHashSet() {
        super(16, .75f, true);
    }
	
    public LinkedHashSet(Collection<? extends E> c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }
```

父类构造器是`HashSet`中的

```java
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        //创建LinkedHashMap
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
```



#### 5.2.2 双向链表

```java
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
```



#### 5.2.3 add()方法

add()方法和HashSet中的add()方法大致相同,只有再**创建节点对象时**不同

```java
 tab[i] = newNode(hash, key, value, null);
```

```java
    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
        LinkedHashMap.Entry<K,V> p = new LinkedHashMap.Entry<>(hash, key, value, e);
        //插入到末尾
        linkNodeLast(p);
        return p;
    }
```



##### 5.2.3.1  linkNodeLast()方法

```java
    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
		//定义最后一个节点副本
        LinkedHashMap.Entry<K,V> last = tail;
		//最后一个节点=p
        tail = p;
		//如果最后一个节点副本=null
        if (last == null)
			//头节点指向最后一个节点
            head = p;
        else {
			//该节点的前一个节点指向最后一个节点副本
            p.before = last;
            //last节点的后一个节点指向p
            last.after = p;
        }
    }
```

![image-20230410192733758](img.assets\image-20230410192733758.png)



### 5.3 TreeSet集合

TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于**`红黑树`**的实现,其特点为：

1. 元素唯一
2. 元素没有索引
3. 使用元素的`自然顺序`对元素进行排序，或者根据创建 TreeSet 时提供的 [`Comparator`](../../java/util/Comparator.html) 比较器进行排序，具体取决于使用的构造方法：

```java
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
```

NavigableSet<E> 是 Java 中的一个接口，继承自 SortedSet<E> 接口，而 SortedSet<E> 接口则继承自 Set<E> 接口。它表示一个按照元素的自然顺序或自定义比较器进行排序的集合，并提供了额外的方法用于在集合中导航和执行基于元素顺序的操作。

Java 中一些常用的 NavigableSet<E> 实现包括 TreeSet<E> 和 ConcurrentSkipListSet<E>。

>E lower(E e): 返回集合中严格小于给定元素的最大元素，如果没有这样的元素，则返回 null。
>E floor(E e): 返回集合中小于或等于给定元素的最大元素，如果没有这样的元素，则返回 null。
>E ceiling(E e): 返回集合中大于或等于给定元素的最小元素，如果没有这样的元素，则返回 null。
>E higher(E e): 返回集合中严格大于给定元素的最小元素，如果没有这样的元素，则返回 null。
>E pollFirst(): 移除并返回集合中的第一个（最低）元素，如果集合为空，则返回 null。
>E pollLast(): 移除并返回集合中的最后一个（最高）元素，如果集合为空，则返回 null



#### 5.3.1 构造函数

```java
    TreeSet(NavigableMap<E,Object> m) {
        this.m = m;
    }
    
    public TreeSet() {
        this(new TreeMap<>());
    }
    
	//自定义比较规则
    public TreeSet(Comparator<? super E> comparator) {
        this(new TreeMap<>(comparator));
    }
```



#### 5.3.2 comparable和Comparator

##### 5.3.2.1 Comparable接口

```java
public interface Comparable<T> {
	public int compareTo(T o);
}
```

`Comparable`接口是Java中的一个接口，用于定义对象之间的自然排序顺序。如果一个类实现了"Comparable"接口，那么该类的对象可以通过实现的"compareTo()"方法进行比较

`Comparable`接口中只有一个方法`compareTo()`，它接受一个参数，表示与当前对象进行比较的对象，通常命名为"o"，返回一个整数值，表示当前对象与参数对象的比较结果。返回的整数值有以下三种情况：

1. 负数：表示当前对象小于参数对象。
2. 0：表示当前对象等于参数对象。
3. 正数：表示当前对象大于参数对象。

实现`Comparable`接口的类应该根据自身的属性来定义比较规则，使得比较结果符合类的排序需求。

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // 构造方法、Getter和Setter等省略

    @Override
    public int compareTo(Person o) {
        // 按照年龄进行比较
        return this.age - o.age;
    }
}
```



##### 5.3.2.2 Comparator接口

```java
@FunctionalInterface
public interface Comparator<T> {
	 int compare(T o1, T o2);
}
```

`Comparator`是Java中的一个接口，用于定义自定义的对象比较规则。通过实现`Comparator`接口，可以定义多个不同的比较规则，用于不同的排序需求

`Comparator`接口中只有一个方法`compare()`，它接受两个参数，分别表示待比较的两个对象，通常命名为"o1"和"o2"，返回一个整数值，表示两个对象的比较结果。返回的整数值有以下三种情况：

1. 负数：表示"o1"小于"o2"。
2. 0：表示"o1"等于"o2"。
3. 正数：表示"o1"大于"o2"。

```java
public class Person {
    private String name;
    private int age;

    // 构造方法、Getter和Setter等省略
}

public class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        // 按照姓名字母顺序进行比较
        return o1.getName().compareTo(o2.getName());
    }
}
```



##### 5.3.2.3 区别

1. `Comparable`：Comparable是Java.lang中的一个接口，用于**`定义对象之间的自然排序顺序`**。如果一个类实现了Comparable接口，那么该类的对象可以通过实现的`compareTo()`方法进行比较。compareTo()方法返回一个整数值，表示当前对象与另一个对象的比较结果，通常返回负数表示小于，返回0表示相等，返回正数表示大于。
2. `Comparator`：Comparator是Java.util中的一个接口，用于**`定义自定义的对象比较规则`**。通过实现Comparator接口，可以定义多个不同的比较规则，用于不同的排序需求。Comparator接口中只有一个方法`compare()`，用于比较两个对象。compare()方法返回一个整数值，表示两个对象的比较结果，通常返回负数表示小于，返回0表示相等，返回正数表示大于。

> 区别

1. 实现方式：Comparable接口是在对象的类中实现的，它要求对象自己定义比较规则。而Comparator接口是在独立的类中实现的，它允许在不修改对象类的情况下定义多个不同的比较规则。
2. 排序方式：Comparable定义的是对象的自然排序规则，而Comparator定义的是自定义的排序规则。自然排序是指对象本身的内在排序规则，而自定义排序是根据比较器定义的外部排序规则。
3. 灵活性：使用Comparator可以实现更加灵活的排序方式，可以根据实际需求在不同的场景中选择不同的比较规则。而使用Comparable，对象的排序规则是固定的，不能动态地改变。
4. 对象修改：实现Comparable接口的类会直接影响到对象的比较规则，而使用Comparator接口可以在不修改对象类的情况下定义比较规则，更加灵活。
5. 同一类多种排序：使用Comparator可以为同一个类定义多个不同的比较规则，而Comparable只能定义一种比较规则



#### 5.3.3 TreeSet比较实现

![img](img.assets\clipboard.png)

- 拿着参数k和集合中的每一个k进行比较 
- 返回值可能是>0 ,<0或=0（使用减法 this.XX - o.XX）返回值的处理（put方法中）

>1. \>0 在右子树上找
>2. <0 在左子树上找
>3. =0 修改Value的值

```java
int cmp;
Entry<K,V> parent;
//自定义比较器
Comparator<? super K> cpr = comparator;
//如果自定义比较器不为null
if (cpr != null) {
    do {
        parent = t;
        //则调用comparator接口中的compare方法
        cmp = cpr.compare(key, t.key);
        if (cmp < 0)
			//小于0放入左子树
            t = t.left;
        else if (cmp > 0)
            //大于0放入左子树
            t = t.right;
        else
            //=0对值进行修改
            return t.setValue(value);
    } while (t != null);
}
//如果自定义比较器为null
else {
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings("unchecked")
    	//使用Comparable接口进行比较，要求比较类必须实现Comparable接口
        Comparable<? super K> k = (Comparable<? super K>) key;
    do {
        parent = t;
        cmp = k.compareTo(t.key);
        if (cmp < 0)
            t = t.left;
        else if (cmp > 0)
            t = t.right;
        else
            return t.setValue(value);
    } while (t != null);
}
```



#### 5.3.4 自平衡二叉树和红黑树的区别

在Java集合框架中，`自平衡二叉树`和"`红黑树`虽然都是用于实现有序映射和有序集合的数据结构，但它们在实现细节和性质上有所不同。

- `自平衡二叉树`（Self-balancing Binary Search Tree）是一种`二叉搜索树`（Binary Search Tree，简称BST），它在`插入和删除节点时会自动调整树的结构，从而保持树的平衡性，防止出现极端不平衡的情况`，保证查找、插入、删除等操作的平均时间复杂度为O(log n)。在Java集合框架中，例如 **TreeSet 和 TreeMap 都是基于自平衡二叉树实现的**。

- `红黑树`（Red-Black Tree）是一种`特定类型的自平衡二叉搜索树`，它在BST的基础上通过一些特定的规则进行了改进，使得`树的高度保持在一定的范围内，从而保持了比较好的平衡性`。红黑树的特点是每个节点都带有颜色标志（红色或黑色），并且满足一定的性质，如根节点和叶节点（空节点）都是黑色的，相邻节点之间的链接没有两个连续的红色节点等。在Java集合框架中，例如 **HashMap 和 TreeMap 使用红黑树作为实现方式来保持键值对的有序性**。
- 可以说红黑树是一种特定类型的自平衡二叉树，而自平衡二叉树则是一类包括了红黑树在内的广义概念。



### 5.4 HashSet、LinkedHashSet和TreeSet三者的异同

`HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。

`HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 **FIFO（先进先出）**。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。

底层数据结构不同又导致这三者的应用场景不同。

- `HashSet` 用于不需要保证元素插入和取出顺序的场景，
- `LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，
- `TreeSet` 用于支持对元素自定义排序规则的场景。



## 6.Queue接口

```java
public interface Queue<E> extends Collection<E>
```

Queue 接口的特点是按照先进先出（FIFO）的原则对元素进行操作，即最先入队的元素最先被出队。

>boolean add(E e)：将指定元素插入队尾，如果队列已满则抛出异常。
>
>boolean offer(E e)：将指定元素插入队尾，如果队列已满则返回 false。
>
>E remove()：移除并返回队头的元素，如果队列为空则抛出异常。
>
>E poll()：移除并返回队头的元素，如果队列为空则返回 null。
>
>E element()：返回队头的元素但不移除，如果队列为空则抛出异常。
>
>E peek()：返回队头的元素但不移除，如果队列为空则返回 null。

Queue 接口有很多实现类，包括 `LinkedList`、`ArrayDeque` 和` PriorityQueue` 等，可以根据需求选择合适的实现类来创建队列对象，并使用 Queue 接口提供的方法进行队列的操作。

**动态数组实现的队列（如 ArrayDeque）**，`默认长度为16`,当队列容量不足时，可以通过创建一个新的数组来扩容，通常将容量扩大为`当前容量的两倍`，然后将原数组中的元素复制到新数组中。



### 6.1  Deque接口

```java
public interface Deque<E> extends Queue<E>
```

在 Java 中，Deque（Double Ended Queue）接口是一种继承自 Queue 接口的`双端队列`（双向队列）数据结构的接口，可以在队头和队尾同时进行插入、删除和获取元素的操作

Deque 接口有很多实现类，包括 `LinkedList` 和 `ArrayDeque` 等。



### 6.2 Queue与Deque的区别

`Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。

`Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值.

| `Queue` 接口 | 抛出异常  | 返回特殊值 |
| ------------ | --------- | ---------- |
| 插入队尾     | add(E e)  | offer(E e) |
| 删除队首     | remove()  | poll()     |
| 查询队首元素 | element() | peek()     |

`Deque` 是双端队列，在队列的两端均可以插入或删除元素。

`Deque` 扩展了 `Queue` 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：

| `Deque` 接口 | 抛出异常      | 返回特殊值      |
| ------------ | ------------- | --------------- |
| 插入队首     | addFirst(E e) | offerFirst(E e) |
| 插入队尾     | addLast(E e)  | offerLast(E e)  |
| 删除队首     | removeFirst() | pollFirst()     |
| 删除队尾     | removeLast()  | pollLast()      |
| 查询队首元素 | getFirst()    | peekFirst()     |
| 查询队尾元素 | getLast()     | peekLast()      |

事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈。



### 6.3 ArrayDeque与LinkedList的区别

`ArrayDeque` 和 `LinkedList` 都实现了 `Deque` 接口，两者都具有队列的功能

- `ArrayDeque` 是基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在JDK1.6才被引入的，而`LinkedList`早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用`ArrayDeque` 来实现队列要比`LinkedList`更好。此外，`ArrayDeque`也可以用于实现栈。



### 6.4 PriorityQueue

`PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

这里列举其相关的一些要点：

- `PriorityQueue` 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据
- `PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- `PriorityQueue` 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

