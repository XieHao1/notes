# 面向对象

## 1.类

- 定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。
- 类中有且仅有5大成分
  - `成员变量Field`：描述类或者对象的属性信息的。
  - `成员方法Method`：描述类或者对象的行为的。
  - `构造器（构造方法,Constructor）`: 初始化类的一个对象返回。
  - `代码块`：
  - `内部类`：



## 2.this

this代表所在类的当前对象的引用（地址值），即代表`当前对象`。

this出现在`实例方法或者实例代码块`中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。

this出现在`构造器`中，代表构造器正在初始化的那个对象。



## 3.封装

封装的作用：提高安全性，==提高代码的组件化思想==。

封装的规范：成员变量私有，方法一般公开，提供成套的getter和setter方法暴露成员变量的取值和赋值。

> private修饰的方法、成员变量、构造器只能在本类中被直接访问 

==private != 封装==

封装已经成为Java代码的规范，即使毫无意义，我们也要这样写代码（成员变量私有，方法公开）

封装的核心思想:`合理隐藏，合理暴露`。



## 4.static

Java中这些成员变量或者方法是**存在所属性的**,有些是属于对象的，有些是属于类本身的。

Java是通过成员变量是否有**`static`**修饰来区分是类的还是属于对象的。

static = 静态 = 修饰的成员(方法和成员变量）属于类本身的。



- ==静态变量==

有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。

- ==实例变量==

无static修饰的成员变量属于每个对象的,这个成员变量叫**实例变量**。

**需要注意的是**：实例成员变量属于每个对象，必须创建类的对象才可以访问。

- ==静态方法==

有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为**类方法或者静态方法**。 直接用类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。

与静态成员变量一样，静态方法也是直接通过**类名.方法名称**即可访问。

- ==实例方法==

无static修饰的成员方法属于每个对象的,这个成员方法叫**实例方法**。**需要注意的是**：实例方法是属于每个对象，必须创建类的对象才可以访问。  

**格式：对象.实例方法**



- **成员变量有2种**
  - 有static修饰的属于类叫静态成员变量，与类一起加载一次，直接用类名调用即可
  - 无static修饰的属于类的每个对象的叫实例成员变量，与类的对象一起加载，对象有多少个，实例成员变量就加载多少份。必须用类的对象调用

- **成员方法有2种:**
  - 有static修饰的属于类叫静态方法，直接用类名调用即可。
  - 无static修饰的属于类的每个对象的叫实例方法，必须用类的对象调用。



## 5.继承

继承描述的是事物之间的所属关系，这种关系是：`is-a` 的关系。父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。

**继承**：就是子类继承父类的**属性**和**行为**，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**`非私有`**的属性和行为。

> 继承的好处

1. 提高**代码的复用性**（减少代码冗余，相同代码重复利用）。
2. 使类与类之间产生了关系。

**需要注意：Java是单继承的，一个类只能继承一个直接父类。**

```java
// 假如Java可以多继承，请看如下代码
class A{
    // 成员方法
    public void test(){
        System.out.println("A");
    }
}

class B{
    // 成员方法
    public void test(){
        System.out.println("B");
    }
}
class C extends  A,B{
    public static void main(String[] args){
        C c = new C();
        c.test(); //出现了类的二义性！所以Java不能多继承！！
    }
}
```





**==继承的特点==：**

1. 单继承： 一个类只能继承一个直接父类
2. 多层继承：一个类可以间接继承多个父类(C继承B,B继承A)
3. 一个类可以有多个子类（C继承B，D也继承B，B就有了C,D两个子类）
4. 一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的超类



==子类不能继承的内容:==

**子类不能继承父类的构造器，因为子类有自己的构造器。**

> 存在争议

**子类可以继承父类的私有成员（成员变量，方法），只是子类`无法直接访问`而已，可以通过getter/setter方法访问父类的private成员变量。**

**子类是不能继承父类的静态成员。**子类只是可以访问父类的静态成员，父类的静态成员只有一份可以被子类共享访问。**`共享并非继承`。**



==继承后成员变量的访问特点：==

**就近原则：子类有就找子类，子类没有找父类，父类没有就报错**

- `this` 代表了当前对象的引用，可以用于访问当前子类对象的成员变量
- `super` 代表了父类对象的引用，可以用于访问父类中的成员变量



### 5.1 方法重写

**方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。**声明不变，重新实现**。

- java建议在重写的方法上面加一个`@override` 注解
- 方法一旦加了这个`@override` 注解，那就必须是成功重写父类的方法，否则报错！
- 建议`“声明不变，重新实现”`。



**方法重写的规范**：

1. 子类重写方法的名称和形参列表必须与父类被重写方法一样
2. 子类重写方法的返回值类型声明要么与父亲一样，要么比父类方法返回值类型范围更小
3. 子类重写方法的修饰符权限应该与父类被重写方法的修饰符权限相同或者范围更大
4. 子类重写方法申明抛出的异常应该与父类被重写方法申明抛出的异常一样或者范围更小

**小结**：

1. 方法重写是子类重写一个与父类申明一样的方法覆盖父类的方法
2. 方法重写要加`@override` 注解
3. 方法重写的核心要求：方法名称，参数列表必须与被重写方法一致！



**扩展**：

- 静态方法和私有方法是否可以被重写？

   答：都不可以，加上`@override`会报错

- **子类继承父类，子类的全部构造器默认会先访问父类的`无参构造器`，再执行子类自己的构造器**

为什么子类的构造器会先调用父类的构造器？

答：1. 子类的构造器的第一行默认有一个`super()`调用父类的无参构造器，写不写都存在

​    2.当我们调用子类构造器初始化子类对象数据的时候，必须先调用父类构造器初始化继承自父类的属性和行为



### 5.2 super和this

- this代表了当前对象的引用(继承中指代子类对象)
  - `this.子类成员变量`
  - `this.子类成员方法`
  - `this(....):可以根据参数匹配访问本类中其他构造器`
- super代表了父类对象的引用(继承中指代了父类对象空间)
  - `super.父类成员变量`
  - `super.父类的成员方法`
  - `super(....):可以根据参数匹配访问父类的构造器`

注意：

- `this(...)`借用本类其他构造器
- `super(...)`调用父类的构造器
- `this(...)和super(...)`必须放在构造器的第一行，否则报错
- 所以`this(...)`和`super(...)`不能同时出现在构造器中！！



## 6.抽象类

**什么是抽象类？**

1. 父类知道子类一定要完成某个功能，但是每个子类完成的情况是不一样的.

2. 子类以后也只会用自己重写的功能，那么父类的该功能就可以定义成抽象方法，子类重写调用子类自己的就行.

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。**我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类**。

- **抽象方法** ：没有方法体的方法。
- **抽象类**：包含抽象方法的类。

> 语法:

**`abstract`是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。**

**`抽象方法`**

使用`abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

定义格式：

```java
修饰符 abstract 返回值类型 方法名 (参数列表)；
```

代码举例：

```java
public abstract void run()；
```



**`抽象类`**

如果一个类包含抽象方法，那么该类必须是抽象类。**注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。**

定义格式：

```java
abstract class 类名字 {}
```

代码举例：

```java
public abstract class Animal {
    public abstract void run()；
}
```

**要求**：继承抽象类的子类**`必须重写父类所有的抽象方法`**。否则，该子类也必须声明为抽象类。

此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做**实现方法**。



> 抽象类的特征

抽象类的特征总结起来可以说是 **有得有失**

**有得：抽象类得到了拥有抽象方法的能力。**

**有失：抽象类失去了创建对象的能力。**

其他成员（构造器，实例方法，静态方法等）抽象类都是具备的。



关于抽象类的使用，以下为语法上要注意的细节

1. 抽象类**`不能创建对象`**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。

   > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

2. 抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。

   > 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。

3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

   > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 

   > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

5. 抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。

   > 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。



### 6.1 重点

**抽象类是否有构造器，抽象类是否可以创建对象？**

1. 抽象类作为类一定有构造器，而且抽象类必须有构造器，是提供给子类创建对象调用父类构造器使用的，除此之外，类中有的成分，抽象类都具备(成员变量，成员方法，构造器，内部类，代码块)

2. 抽象类虽然有构造器但是抽象类不能创建对象



**抽象类中的构造器可以私有吗?**

从代码编译角度，抽象类中的构造器可以私有，但是子类继承默认调用父类构造器会报错,**因为私有只能在本类中使用**，所以抽象类中构造器私有没有意义



**抽象类存在的意义**

1. 抽象类就是为了被子类继承(就是为了派生子类)，否则抽象类毫无意义

2. 抽象类体现的是模板思想，部分实现，部分抽象，可以设计`模板设计模式`

 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现



### 6.2 模板设计模式

模板设计模式的作用:优化代码架构，提高代码的复用性，相同功能的重复代码无需反复书写

可以做到部分实现，部分抽象，抽象的东西交给使用模板的人重写实现!

我们可以将`固定流程写到父类`中，不同的地方就定义成抽象方法，让不同的子类去重写，代码如下:

```java
//司机开车模板
public abstract class template {
    public void go(){
        System.out.println("开门");
        System.out.println("点火");
        //开车姿势不确定,需要子类进行重写
        posture();
        System.out.println("刹车");
        System.out.println("熄火");
    }

    //定义车的姿势
    public abstract void posture();
}
```

**可以看出，模板模式的优势是，模板已经定义了通用架构，使用者只需要关心自己需要实现的功能即可！！**



## 7.接口

**接口是更加彻底的抽象，接口中全部是抽象方法。（JDK8之前），接口同样是不能创建对象的**。

```java
//接口的定义格式：
修饰符 interface 接口名称{
    // 抽象方法
}
```

==抽象体现的是模板的思想,接口体现的是规范的思想==

> 抽象方法

   注意：接口中的抽象方法默认会自动加上public abstract
​   按照规范：以后接口中的抽象方法建议不要写上public abstract。

> 常量

 在接口中定义的成员变量默认会加上：` public static final`修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。



> **`子类继承父类，实现类实现接口`**

- 类与类是继承关系
- 类与接口是实现关系，接口是被类实现的
- 实现接口的类称为：实现类
- **一个类实现接口必须重写完接口中的全部抽象方法，否则这个类要定义成抽象类**（一个类继承抽象类，必须重写完抽象类的所有抽象方法，否则这个类要定义成抽象类）
- 类实现接口的格式：

```java
修饰符 class 实现类名称 implements 接口1,接口2,接口3,.....{
    
}

implements: 类实现接口的关键字
```

- ==类于类是单继承关系，类与接口是多实现关系，接口与接口是多继承关系==
  - 一个类只能继承一个直接父类
  - 一个类可以同时实现多个接口
  - 一个接口可以同时继承多个接口

```java
public interface Abc {
    void go();
    void test();
}

/** 法律规范：接口*/
public interface Law {
    void rule();
    void test();
}
/
 *
 *  总结：
 *     接口与类之间是多实现的。
 *     接口与接口之间是多继承的。
 * */
public interface SportMan extends Law , Abc {
    void run();
}
```

- 一个类实现多个接口，必须重写完全部接口中的全部抽象方法，否则这个类要定义成抽象类



### 7.1 JDK 8之后的接口新增方法

从JDK 8开始之后，接口不再纯洁了，接口中不再只是抽象方法，接口还可以有**默认方法**（也就是实例方法），和**静态方法**了，还包含了私有实例方法和私有静态方法

> 含有默认方法和静态方法

**默认方法：使用 `default` 修饰，不可省略，供子类调用或者子类重写。**只能用接口的实现类的对象来调用

**静态方法：使用 `static` 修饰，供接口直接调用。**接口的静态方法只能用接口的类名称本身调用

```java
    default void A() {
        System.out.println("默认方法");
    }

    static void B() {
        System.out.println("静态方法");
    }
```

> 含有私有方法和私有静态方法

- 其实就是私有的实例方法，必须加`private`修饰(JDK1.9开始才支持)

```java
private void C();
```

默认方法和静态方法以及私有方法和私有静态方法**，**遵循面向对象的继承关系使用原则，实现类依然可以访问接口的非私有方法，对于接口中的非私有静态方法，可以直接通过接口名进行访问。

重写默认方法注意（了解）:

* 子接口重写默认方法时，default关键字可以保留。

* 实现类重写默认方法时，default关键字不可以保留。





### 7.2 实现多个接口的使用注意事项

1. 如果实现了多个接口，多个接口中存在同名的`静态方法`并不会冲突.原因是只能通过各自接口名访问静态方法

2. **当一个类，既继承了一个父类，又实现了若干个接口时，父类中成员方法和接口中的默认方法重名，子类就近选择执行`父类的成员方法`**

3. 当一个类实现多个接口时，多个接口中存在同名的`默认方法`，实现类必须重写这个方法

4. **接口中，没有构造器，不能创建对象**

   接口是更彻底的抽象，连构造器都没有，自然不能创建对象！

   构造器：初始化一个类的对象并返回引用



## 8.代码块

类的成分：
    1.成员变量
    2.构造器
    3.成员方法
    4.代码块
    5.内部类

代码块按照有无`static`修饰分为：`静态代码块`，`实例代码块`

### 8.1 静态代码块

- 必须用`static`修饰，属于类，会与类一起优先加载，而且自动触发执行一次！
- 静态代码块可以用于执行类的方法之前进行静态资源的初始化操作
- 格式：

```java
static{
    
}
```

**特点**：

- 每次执行类，加载类的时候都会先执行静态代码块一次。
- 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。
- 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。



### 8.2 实例代码块

- 必须无`static`修饰，属于类的每个对象，会与类的每个对象一起加载，每次`创建对象`的时候，实例代码块就会触发执行一次
- 实例代码块可以用于初始化实例资源
- 实例代码块的代码实际上是提取到每个构造器中去执行的



## 9.final关键字

1. `final`修饰类：类不能被继承
2. `final`修饰方法：方法不能被重写
3. `final`修饰变量：变量有且仅能被赋值一次



- 成员变量和局部变量

- 静态成员变量：有`static`修饰，属于类，只加载一份

  - `final`修饰静态成员变量，变量变成了常量

- 实例成员变量：无`static`修饰，属于每个对象，与对象一起加载

  成员变量涉及到初始化的问题，初始化方式有显示初始化和构造器初始化，只能选择其中一个：

  **显示初始化(在定义成员变量的时候立马赋值)；**

  ```java
  public class Student {
      final int num = 10;
  }
  ```

  **构造器初始化(在构造器中赋值一次)**。注意：`每个构造器中都要赋值一次！`

  ```java
  public class Student {
      final int num = 10;
      final int num2;
  
      public Student() {
          this.num2 = 20;
      }
      
       public Student(String name) {
          this.num2 = 20;
      }
  }
  ```

- 局部变量：在方法中，构造器中，代码块中，for循环中的变量，用完作用范围就消失了

  - `final`修饰局部变量：让值被固定或者说保护起来，执行过程中防止被修改

> 被final修饰的常量名称，一般都有书写规范，所有字母都**大写**。



## 10.单例设计模式

单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个`类只有一个实例`。即一个类只有一个对象实例。

**==单例设计模式实现步骤==**

1. 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。

2. 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。

3. 定义一个静态方法返回这个唯一对象。



根据实例化对象的时机单例设计模式又分为以下两种:

1. 饿汉单例设计模式

2. 懒汉单例设计模式



### 10.1 饿汉单例设计模式

饿汉单例设计模式就是使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故被称为“饿汉模式”。

1. 定义一个单例类
2. 把类的构造器私有
3. 定义一个静态成员变量用于存储一个对象！(饿汉单例在返回对象的时候，对象要已经做好)
4. 定义一个方法返回单例对象

```java
public class Singleton {

    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。
    private static final Singleton singleton = new Singleton();

    //1.构造器私有化
    private Singleton() {
    }

    // 3.定义一个静态方法返回这个唯一对象。
    public static Singleton getInstance() {
        return singleton;
    }
}
```



### 10.2 懒汉单例设计模式

懒汉单例设计模式就是调用`getInstance()`方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象。不着急，故称为“懒汉模式”。

1. 定义一个单例类
2. 把类的构造器私有
3. 定义一个静态成员变量用于存储一个对象(懒汉单例不能直接创建对象，必须需要的时候才去创建)
4. 定义一个方法返回单例对象，判断对象不存在才创建一次，存在直接返回

```java
public class Singleton {

    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。
    private static Singleton singleton;

    //1.构造器私有化
    private Singleton() {
    }

    // 3.定义一个静态方法返回这个唯一对象。
    public static Singleton getInstance() {
        if (Objects.isNull(singleton)) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

> 注意：懒汉单例设计模式在多线程环境下可能会实例化出多个对象，不能保证单例的状态。
>
> - 线程的不安全问题发生在`首次创建`实例对象时，如果多个线程同时调用getInstance方法，就可能创建出多个实例
>
> - 一旦实例已经创建好，后面在多线程环境再调用getInstance方法就不存在线程安全问题了

### 10.3 双检索模式实现懒汉

具体操作：①使用双重if判定，降低锁竞争的频率；②给singleton加上了`volatile`

```java
public class Singleton {

    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。
    private static volatile Singleton singleton;

    //1.构造器私有化
    private Singleton() {
    }

    // 3.定义一个静态方法返回这个唯一对象。
    public static Singleton getInstance() {
        if (Objects.isNull(singleton)) {
            synchronized (singleton) {
                if (Objects.isNull(singleton)) {
                    singleton = new Singleton();
                }
                return singleton;
            }
        }
        return singleton;
    }
}
```



## 11.枚举

枚举的作用：一个方法接收的参数是固定范围之内的时候，那么即可使用枚举。

**枚举通常可以用于做信息的分类，如性别，方向，季度等。**

```java
enum 枚举名 {
    //第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。
}
```



**`枚举类的特点`**

- 枚举类是`final`修饰的，不能被继承

```java
enum Sex {
    BOY, GIRL; // 男，女
}

// 枚举的本质是一个类，我们刚才定义的Sex枚举相当于下面的类

//反编译class文件
javap EnumDemo.class

Compiled from "EnumDemo.java"
public final class day01.EnumDemo extends java.lang.Enum<day01.EnumDemo> {
 //枚举类的第一行罗列的是枚举类的对象，而且使用常量存储的
  public static final day01.EnumDemo BOY;
  public static final day01.EnumDemo GIRL;
  public static day01.EnumDemo[] values();
  public static day01.EnumDemo valueOf(java.lang.String);
  static {};
}
```

- 枚举类的第一行罗列的是枚举类的对象，而且使用常量存储的,所以枚举类的第一行写的都是常量名称，默认存储了枚举对象
- 枚举类的构造器默认是`私有`的

```java
public enum EnumDemo {
    BOY,
    GIRL;

    private EnumDemo() {
    }
}
```

- 枚举类相当于是`多例设计`对象



## 12.多态

概念：同一个类型的对象，执行同一个行为，在不同状态下会表现出不同的行为特征

> 多态形式

- 父类类型 对象名称 = new 子类构造器
- `Anilam c = new Cat()`
- 接口 对象名称 = new 实现类构造器
- 父类类型范围 > 子类类型范围

- 对于方法的调用：**编译(写代码)看左边，运行看右边**
- 对于变量的调用：**编译看左边，运行看左边**



### 12.1 多态的使用前提

1. **必须存在继承或者实现关系**
2. **必须存在父类类型的变量引用(指向)子类类型的对象**
3. **需要存在方法重写**



### 12.2 多态的优劣势

`优势`

- 在多态形式下，右边对象可以实现组件化切换，业务功能也随之改变，便于扩展和维护。可以实现类与类之间的解耦
- 实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的扩展性与便利

`劣势`

- 多态形式下，不能直接调用子类特有的功能。（编译看左边!!）
- 因为父类中没有子类独有的功能，所以代码在编译阶段就直接报错了



### 12.3 引用类型的强制类型转换

- **父类类型的变量或者对象必须强制类型转换成子类类型的变量，否则报错！**

- 强制类型转换的格式：

  - 类型 变量名称 = (类型)（对象或者变量）

  - ```java
    Animal a = new Wolf();
    // 把动物类型的变量a转换为真实的狼类型
    Wolf w = (Wolf) a;
    ```



- 有继承/实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错
- 但是在运行阶段可能出现：**类型转换异常** `ClassCastException`
- **建议在进行强制类型转换之前先判断变量的真实类型，再强制类型转换**(`instanceof`)

```java
Animal a1 = new Cat();
// Wolf w1 = (Wolf) a1; //编译阶段没有报错 在运行阶段可能出现类型转换异常
if(a1 instanceof Cat){
    // 如果a1 属于猫类型,执行抓老鼠
    Cat c1 = (Cat) a1;
    c1.catchMouse();
}else if(a1 instanceof Wolf){
    // 如果a1 属于狼类型，执行抓羊
    Wolf w1 =(Wolf) a1;
    w1.catchSheep();
}
```



## 13.内部类

定义在一个类里面的类就是内部类

**内部类有什么用？**

可以提供更好的封装性，内部类有更多的权限修饰符，封装性有了更多的控制



**内部类的分类**

- 静态内部类
- 实例内部类(成员内部类)
- 局部内部类
- **匿名内部类(重点)**



### 13.1 静态内部类

有`static`修饰，属于`外部类`本身，会加载一次

**静态内部类的成分**

- 类中有的成分它都有，静态内部类属于外部类本身，只会加载一次
- 所以它的特点与外部类是完全一样的，只是位置在别人里面而已



**静态内部类的访问格式**

`外部类名称.内部类名称`



**静态内部类创建对象的格式**

外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器



**静态内部类中是否可以直接访问外部类的静态成员？**

可以的，外部类的静态成员只有一份，可以被共享



**静态内部类中是否可以直接访问外部类的实例成员？**

不可以，外部类的实例成员必须用外部类对象访问



### 13.2 实例内部类

**什么是实例内部类？**

无`static`修饰的内部类，属于外部类的每个对象，跟着对象一起加载



**实例内部类中的成分**

`实例内部类中不能定义静态成员`，其他的都可以定义，`可以定义常量`



**实例内部类的访问格式**

外部类名称.内部类名称



**实例内部类创建对象的格式**

外部类名称.内部类名称 对象名称 = **`new 外部类构造器.new 内部类构造器`**



**实例内部类中是否可以直接访问外部类的静态成员？**

可以的，外部类的静态成员可以被共享访问



**实例内部类中是否可以访问外部类的实例成员？**

可以的，实例内部类属于外部类对象，可以直接访问当前外部类的实例成员



> 注意：内部类访问外部类对象的格式是：**`外部类名.this`**

```java
class Body {    // 身体
        private int weight = 30;

        // 在成员位置定义一个类
        class Heart {
            private int weight = 20;

            public void jump() {
                int weight = 10;
                System.out.println("心脏在跳动 " + weight);    // 10
                System.out.println("心脏在跳动 " + this.weight);    // 20
                System.out.println("心脏在跳动 " + Body.this.weight);    // 30
            }
        }
    }
```



### 13.3 局部内部类

**什么是局部内部类？**

在方法，构造器，代码块，for循环中定义的内部类，就是局部内部类

```java
public class InnerClass {
    static {
        // 局部内部类
        abstract class A{

        }
    }
    public static void main(String[] args) {
        // 局部内部类
        class A{


        }
    }
    public static void test(){
        // 局部内部类
        class Animal{

        }
        // 局部内部类
        class A extends Animal{

        }
    }
}
```

**局部内部类的成分**

`只能定义实例成员`，不能定义静态成员，可以定义常量



### 13.4 匿名内部类

`一个没有名字的局部内部类`

匿名内部类可以简化代码，是开发中常用的形式

**匿名内部类的格式**

```java
new 类名|抽象类|接口(形参){
    方法重写
}
```

**匿名内部类的特点**

 1.匿名内部类是一个没有名字的内部类

 2.**匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回**

 3.**匿名内部类的对象的类型相当于是当前 new 的那个类型的子类类型**



## 14.包

**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。

- 包名一般是公司域名的倒写

- 包名必须用”.“连接。
- 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。



## 15.权限修饰符

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限

- public：公共的，所有地方都可以访问。
- protected：当前类 ，当前包，当前类的子类可以访问。
- 缺省（没有修饰符）：当前类 ，当前包可以访问。
- private：私有的，当前类可以访问。
  `public > protected > 缺省 > private`

|                  | public | protected | 缺省（空的） | private |
| ---------------- | ------ | --------- | ------------ | ------- |
| 同一类中         | √      | √         | √            | √       |
| 同一包中的类     | √      | √         | √            |         |
| 不同包的子类     | √      | √         |              |         |
| 不同包中的无关类 | √      |           |              |         |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用`private` ，隐藏细节。
- 构造方法使用` public` ，方便创建对象。
- 成员方法使用`public` ，方便调用方法。

> 不加权限修饰符，就是default权限