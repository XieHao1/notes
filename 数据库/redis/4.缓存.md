# 缓存

# 1.缓存

**缓存(**Cache),就是数据交换的**缓冲区**,俗称的缓存就是**缓冲区内的数据**,一般从数据库中获取,存储于本地代码(例如:

```java
例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发

例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存

例3:Static final Map<K,V> map =  new HashMap(); 本地缓存
```

由于其被**Static**修饰,所以随着类的加载而被加载到**内存之中**,作为本地缓存,由于其又被**final**修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;



## 1.1 缓存的好处

一句话:因为**速度快,好用**

缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低**用户访问并发量带来的**服务器读写压力

实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存,系统是几乎撑不住的,所以企业会大量运用到缓存技术;

但是缓存也会增加代码复杂度和运营的成本:

![image-20230606151749561](img.asstes\image-20230606151749561.png)



## 1.2 使用缓存

实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用

**浏览器缓存**：主要是存在于浏览器端的缓存

**应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存

**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中

**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存

![image-20230606151821836](img.asstes\image-20230606151821836.png)

# 2. 添加缓存

标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。

![image-20230606152051084](img.asstes\image-20230606152051084.png)

## 2.1 查询商铺缓存流程

![image-20230606152134131](img.asstes\image-20230606152134131.png)

> 代码

```java
    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        //从redis中查询
        String shopJSON = stringRedisTemplate.opsForValue().get(CACHE_SHOP_PREFIX + id);
        if (StrUtil.isNotBlank(shopJSON)) {
            //直接返回
            Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
            return Result.ok(shop);
        }
        //如果redis中不存在
        Shop shop = shopService.getById(id);
        if (Objects.isNull(shop)) {
            return Result.fail("商铺信息不存在");
        }
        //存在存入redis中
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, JSONUtil.toJsonStr(shop));
        return Result.ok(shop);
    }
```



## 2.2 缓存更新策略

缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。

**内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)

**超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存

**主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

![image-20230606154330255](img.asstes\image-20230606154330255.png)

业务场景:

- 低一致性需求:使用内存淘汰机制。例如店铺类型的查询缓存

- 高一致性需求:主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存



### 2.2.1 主动更新

![image-20230606155202640](img.asstes\image-20230606155202640.png)

操作缓存和数据库时有三个问题需要考虑：

如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来

* 删除缓存还是更新缓存？
  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存--`建议删除`

* 如何保证缓存与数据库的操作的同时成功或失败？
  * 单体系统，将缓存与数据库操作放在一个事务
  * 分布式系统，利用TCC等分布式事务方案
* 先操作缓存还是先操作数据库？
  * 先删除缓存，再操作数据库
  * 先操作数据库，再删除缓存

应该具体操作缓存还是操作数据库，我们应当是`先操作数据库，再删除缓存`，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。

![image-20230606155833283](img.asstes\image-20230606155833283.png)

### 2.2.2 缓存更新最佳实践方案

缓存更新策略的最佳实践方案：

1. 低一致性需求：使用Redis自带的内存淘汰机制

2. 高一致性需求：主动更新，并以超时剔除作为兜底方案

- 读操作：
  - 缓存命中则直接返回
  - 缓存未命中则查询数据库，并写入缓存，设定超时时间

- 写操作：
  - 先写数据库，然后再删除缓存
  - 要确保数据库与缓存操作的原子性



## 2.3 添加商铺缓存超时和主动更新

修改ShopController中的业务逻辑，满足下面的需求：

根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

根据id修改店铺时，先修改数据库，再删除缓存

> 更新操作

```java
    @PutMapping
    @Transactional
    public Result updateShop(@RequestBody Shop shop) {
        // 写入数据库
        shopService.updateById(shop);
        //删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_PREFIX + shop.getId());
        return Result.ok();
    }
```



# 3. 缓存穿透

`缓存穿透` ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

常见的解决方案有两种：

* `缓存空对象`
  * 优点：实现简单，维护方便
  * 缺点：
    * 额外的内存消耗
    * 可能造成短期的不一致

**缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了

> 缓存空对象

![image-20230606162001372](img.asstes\image-20230606162001372.png)

`布隆过滤`

* 优点：内存占用较少，没有多余key
* 缺点：
  * 实现复杂
  * 存在误判可能

**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，

假设布隆过滤器判断这个数据不存在，则直接返回

这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突

> 布隆过滤器

![image-20230606162314155](img.asstes\image-20230606162314155.png)

### 3.1 缓存空对象实现

在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的

现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。

![image-20230606162658676](img.asstes\image-20230606162658676.png)

> 代码实现

```java
    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        //从redis中查询
        String shopJSON = stringRedisTemplate.opsForValue().get(CACHE_SHOP_PREFIX + id);
        if (StrUtil.isNotBlank(shopJSON)) {
            //直接返回
            Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
            return Result.ok(shop);
        }
        //判断返回的数据是否为空字符串
        if (StrUtil.equals("", shopJSON)) {
            return Result.fail("商铺信息不存在");
        }
        //如果redis中不存在
        Shop shop = shopService.getById(id);
        if (Objects.isNull(shop)) {
            //写入空字符串，防止缓存穿透
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, "", 2L, TimeUnit.MINUTES);
            return Result.fail("商铺信息不存在");
        }
        //存在存入redis中
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, JSONUtil.toJsonStr(shop), 30L, TimeUnit.MINUTES);
        return Result.ok(shop);
    }
```





### 3.2 使用BitMap解决缓存穿透

我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。

![image-20230630194709477](img.asstes\image-20230630194709477.png)

现在的问题是这个主键其实并没有那么短，而是很长的一个主键，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间

我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用**`哈希思想`**，比如：

**id % bitmap.size**  = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。

![image-20230630194909274](img.asstes\image-20230630194909274.png)



### 3.3 总结

缓存穿透产生的原因是什么？

* 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力

缓存穿透的解决方案有哪些？

* 缓存null值
* 布隆过滤
* 增强id的复杂度，避免被猜测id规律
* 做好数据的基础格式校验
* 加强用户权限校验
* 做好热点参数的限流



# 4. 缓存雪崩

缓存雪崩是指在同一时段大量的`缓存key同时失效`或者`Redis服务宕机`，导致大量请求到达数据库，带来巨大压力。

![image-20230606164329861](img.asstes\image-20230606164329861.png)

> 解决方案

* 给不同的Key的TTL添加随机值
* 利用Redis集群提高服务的可用性
* 给缓存业务添加降级限流策略
* 给业务添加多级缓存



# 5. 缓存击穿

**缓存击穿问题**也叫热点Key问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

![image-20230606164915309](img.asstes\image-20230606164915309.png)

> 常见的解决方案有两种：

* 互斥锁
* 逻辑过期

## 5.1 互斥锁

因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用`tryLock方法 + double check`来解决这样的问题。

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

![image-20230606165657469](img.asstes\image-20230606165657469.png)

> 利用互斥锁解决缓存击穿问题

核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行`互斥锁的获取`，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询

如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿

![image-20230606165838184](img.asstes\image-20230606165838184.png)

**操作锁的代码：**

核心思路就是利用redis的**`setnx`**方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。

```java
    private boolean tryLock(String key) {
        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10L, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(lock);
    }

    private void unLock(String key){
        stringRedisTemplate.delete(key);
    }
```

> 互斥锁流程实现

```java
    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        String shopJSON = stringRedisTemplate.opsForValue().get(CACHE_SHOP_PREFIX + id);
        if (StrUtil.isNotBlank(shopJSON)) {
            Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
            return Result.ok(shop);
        }
        if (StrUtil.equals("", shopJSON)) {
            return Result.fail("商铺信息不存在");
        }
        Shop shop = null;
        try {
            //获取锁
            boolean lock = this.tryLock("shop:lock" + id);
            //如果锁获取失败,则休眠一段时间，在重新执行
            if (!lock) {
                Thread.sleep(50);
                //直接返回，不在执行下面的代码
                return queryShopById(id);
            }
            //成功获取锁之后，再一次检查redis中是否有缓存
            shopJSON = stringRedisTemplate.opsForValue().get(CACHE_SHOP_PREFIX + id);
            if (StrUtil.isNotBlank(shopJSON)) {
                shop = JSONUtil.toBean(shopJSON, Shop.class);
                return Result.ok(shop);
            }
            //如果redis中还是没有缓存，则添加缓存
            shop = shopService.getById(id);
            if (Objects.isNull(shop)) {
                stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, "", 2L, TimeUnit.MINUTES);
                return Result.fail("商铺信息不存在");
            }
            stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, JSONUtil.toJsonStr(shop), 30L, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            //释放锁
            this.unLock("shop:lock" + id);
        }
        return Result.ok(shop);
    }
```



## 5.2 逻辑过期

解决方案二、逻辑过期方案

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

我们把`过期时间设置在redis的value`中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

![image-20230606193450385](img.asstes\image-20230606193450385.png)



**需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题**

思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

![image-20230606200547530](img.asstes\image-20230606200547530.png)

> 封装缓存时间

```java
//减少代码的入侵性
@Data
public class RedisExpired<T> {
    private LocalDateTime localDateTime;
    private T data;
}
```

> 请求预热

```java
    private void saveShopToRedis(Long id, Long expiredTimeSeconds) {
        //查询数据
        Shop shop = shopService.getById(id);
        //封装逻辑过期时间
        RedisExpired<Shop> redisExpired = new RedisExpired<>();
        redisExpired.setData(shop);
        redisExpired.setLocalDateTime(LocalDateTime.now().plusSeconds(expiredTimeSeconds));
        //写入redis,不设置过期时间
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, JSONUtil.toJsonStr(redisExpired));
    }
```

> 逻辑过期实现

```java
	//创建线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        //先从Redis中获取
        String shopJSON = stringRedisTemplate.opsForValue().get(CACHE_SHOP_PREFIX + id);
        if (StrUtil.isBlank(shopJSON)) {
            //如果shopJSON为命中或者是空字符串(防止缓存穿透)
            return Result.fail("商铺信息不存在");
        }
        //命中
        //将json转换为redisExpired对象
        RedisExpired redisExpired = JSONUtil.toBean(shopJSON, RedisExpired.class);
        Shop shop = BeanUtil.copyProperties(redisExpired.getData(), Shop.class);
        LocalDateTime localDateTime = redisExpired.getLocalDateTime();
        //判断缓存是否过期
        if (localDateTime.isAfter(LocalDateTime.now())) {
            //未过期
            return Result.ok(shop);
        }
        //过期，获取锁
        boolean lock = this.tryLock("shop:lock" + id);
        //如果获取锁成功
        if (lock) {
            //开启独立线程进行缓存更新
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    //执行缓存的更新操作
                    this.saveShopToRedis(id, 20L);
                } finally {
                    //释放锁
                    this.unLock("shop:lock" + id);
                }
            });
        }
        //如果没有获取到锁,则直接返回旧数据
        return Result.ok(shop);
    }
```



# 6. Redis工具类

```java
@Component
public class CacheClient {

    @Resource
    private StringRedisTemplate stringRedisTemplate;
    //线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    private static final String LOCK_PREFIX = "lock";


    /**
     * 使用逻辑删除解决缓存击穿
     *
     * @param key        缓存key
     * @param type       返回类型
     * @param id         主键id
     * @param dbFallBack 根据主键擦查询数据库方法
     * @param time       时间
     * @param unit       时间单位
     * @param <R>        返回类型
     * @param <ID>       主键类型
     * @return 获取并且缓存数据
     */
    public <R, ID> R queryWithLogicalExpire(String key, Class<R> type, ID id, Function<ID, R> dbFallBack, Long time, TimeUnit unit) {
        //查询缓存
        String cacheKey = key + ":" + id;
        String json = stringRedisTemplate.opsForValue().get(cacheKey);
        //如果缓存未命中
        if (StrUtil.isBlank(json)) {
            return null;
        }
        //如果缓存命中，则获取逻辑过期时间
        RedisExpired redisExpired = JSONUtil.toBean(json, RedisExpired.class);
        //获取过期时间
        LocalDateTime localDateTime = redisExpired.getLocalDateTime();
        //获取数据
        R data = JSONUtil.toBean((JSONObject) redisExpired.getData(), type);
        //如果逻辑过期时间为过期，则直接返回
        if (localDateTime.isAfter(LocalDateTime.now())) {
            return data;
        }
        //如果逻辑时间过期,则更新缓存
        //获取锁
        Boolean tryLock = this.tryLock(type.getSimpleName(), id);
        //如果获取锁成功
        if (tryLock) {
            //启动另一个线程执行更新操作
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    //查询数据库
                    R apply = dbFallBack.apply(id);
                    if (Objects.isNull(apply)) {
                        //如果查询出来的为null，则设置空值,防止缓存穿透
                        this.set(key, "", 5L, TimeUnit.SECONDS);
                    }
                    //更新数据库缓存
                    this.set(key, apply, time, unit);
                } finally {
                    //释放锁
                    this.unLock(type.getSimpleName(), id);
                }
            });
        }
        //直接返回旧数据
        return data;
    }

    /**
     * 使用互斥锁解决缓存击穿
     *
     * @param key        缓存key前缀
     * @param type       返回类型
     * @param id         主键id
     * @param dbFallback 根据主键擦查询数据库方法
     * @param time       时间
     * @param unit       时间单位
     * @param <R>        返回值类型
     * @param <ID>       主键类型
     * @return 获取并且缓存数据
     */
    public <R, ID> R queryWithMute(String key, Class<R> type, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String cacheKey = key + ":" + id;
        String json = stringRedisTemplate.opsForValue().get(cacheKey);
        //如果缓存命中
        if (StrUtil.isNotBlank(json)) {
            return JSONUtil.toBean(json, type);
        }
        //如果缓存为空串，解决缓存穿透问题
        if (StrUtil.equals("", json)) {
            return null;
        }
        //如果缓存未命中，则查询数据库，并且重新添加到缓存中
        //使用互斥锁解决缓存击穿
        //获取锁
        try {
            Boolean tryLock = tryLock(type.getSimpleName(), id);
            //如果获取锁失败
            if (!tryLock) {
                //一段时间后再执行
                Thread.sleep(50);
                return queryWithMute(key, type, id, dbFallback, time, unit);
            }
            //如果获取锁成功，再次查询redis中是否有数据
            json = stringRedisTemplate.opsForValue().get(cacheKey);
            //如果缓存命中
            if (StrUtil.isNotBlank(json)) {
                return JSONUtil.toBean(json, type);
            }
            //如果redis中不存在，则添加缓存
            //从数据库中查询
            R apply = dbFallback.apply(id);
            //如果数据库中不存在，则设置未null
            if (Objects.isNull(apply)) {
                stringRedisTemplate.opsForValue().set(cacheKey, "", 5L, TimeUnit.SECONDS);
                return null;
            }
            //将数据放入到redis中
            this.set(cacheKey, apply, time, unit);
            //返回
            return apply;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            //释放锁
            unLock(type.getSimpleName(), id);
        }
    }

    /**
     * 加锁
     *
     * @param typeName 类名称
     * @param id       锁id
     * @param <ID>     锁id类型
     * @return 是否加锁成功
     */
    private <ID> Boolean tryLock(String typeName, ID id) {
        String key = LOCK_PREFIX + ":" + typeName + ":" + id;
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 5L, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(flag);
    }

    /**
     * 释放锁
     *
     * @param typeName 类名称
     * @param id       锁id
     * @param <ID>     锁id类型
     */
    private <ID> void unLock(String typeName, ID id) {
        String key = LOCK_PREFIX + ":" + typeName + ":" + id;
        stringRedisTemplate.delete(key);
    }

    /**
     * 缓存穿透，使用缓存空值的方式解决
     *
     * @param key        缓存key前缀
     * @param type       要返回值的类型
     * @param id         数据库查询id
     * @param dbFallback 根据主键查询数据库的方法
     * @param time       时间
     * @param unit       时间单位
     * @param <R>        返回值类型
     * @param <T>        主键类型
     * @return 返回查询后的类对象
     */
    public <R, T> R queryWithPassThrough(String key, Class<R> type, T id, Function<T, R> dbFallback, Long time, TimeUnit unit) {
        String cacheKey = key + ":" + id;
        //从缓存中查询
        String json = stringRedisTemplate.opsForValue().get(cacheKey);
        //如果查询命中
        if (StrUtil.isNotBlank(json)) {
            return JSONUtil.toBean(json, type);
        }
        //如果缓存未命中
        //判断JSON是否为空值，处理缓存穿透
        if (StrUtil.equals("", json)) {
            return null;
        }
        //在数据库中查询
        R apply = dbFallback.apply(id);
        //如何数据中没有该数据，则缓存空值
        if (Objects.isNull(apply)) {
            this.set(cacheKey, "", time, unit);
            return null;
        }
        //缓存该数据
        this.set(cacheKey, JSONUtil.toJsonStr(apply), time, unit);
        //返回
        return apply;
    }

    /**
     * 将数据缓存到redis中，并且指定过期时间
     *
     * @param key  redisKey
     * @param data 数据
     * @param time 时间
     * @param unit 时间单位
     */
    public void set(String key, Object data, Long time, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(data), time, unit);
    }

    /**
     * 将数据缓存到redis中，并且设置逻辑删除时间-处理缓存击穿
     *
     * @param key  redis的key
     * @param data 数据
     * @param time 时间
     * @param unit 时间单位
     */
    public void setWithLogicalExpire(String key, Object data, Long time, TimeUnit unit) {
        RedisExpired redisExpired = new RedisExpired();
        Duration duration = Duration.of(time, getChronoUnit(unit));
        redisExpired.setLocalDateTime(LocalDateTime.now().plus(duration));
        redisExpired.setData(data);
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisExpired));
    }

    /**
     * ChronoUnit-Java8中的一个枚举类
     *
     * @param unit 是java标准库中的一个枚举类，用于表示时间单位
     * @return ChronoUnit类
     */
    private ChronoUnit getChronoUnit(TimeUnit unit) {
        if (unit == TimeUnit.SECONDS) {
            return ChronoUnit.SECONDS;
        } else if (unit == TimeUnit.MINUTES) {
            return ChronoUnit.MINUTES;
        } else if (unit == TimeUnit.HOURS) {
            return ChronoUnit.HOURS;
        } else if (unit == TimeUnit.DAYS) {
            return ChronoUnit.DAYS;
        }
        // 默认返回秒作为时间单位
        return ChronoUnit.SECONDS;
    }
}
```

