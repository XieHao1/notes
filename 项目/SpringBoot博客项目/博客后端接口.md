[TOC]



# 一.项目搭建

## 1.项目使用技术 

​	springboot + mybatisplus+redis+mysql+Vue



## 2.项目所需依赖

```xml
 <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--mybatis-plus起步依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.3.4</version>
        </dependency>

        <!-- Springboot-redis依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!--  mysql驱动  -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.30</version>
        </dependency>

        <!--aop依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>

        <!-- 邮件依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!--给自定义的配置类生成元数据信息-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <!--java.lang包的增强版本-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>

        <!--增强了Java集合框架-->
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2.2</version>
        </dependency>

        <!--专门处理日期时间的库-->
        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
            <version>2.10.10</version>
        </dependency>

        <!--引入jwt-->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.4.0</version>
        </dependency>

        <!-- Springboot-redis依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.8.2</version>
        </dependency>

	<!-- 使用七牛云储存图片  -->
        <dependency>
            <groupId>com.qiniu</groupId>
            <artifactId>qiniu-java-sdk</artifactId>
            <version>[7.7.0, 7.7.99]</version>
        </dependency>
```

## 3.配置

### (1).propertites文件配置 

```properties
#设置后端端口，防止和前端端口冲突
server.port=8888

#指定应用的名称，在spring cloud中被用来注册的服务名
spring.application.name=bolg

spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xh_blog
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

#mybatis-plus配置
mybatis-plus.mapper-locations=classpath:mapper/*.xml
#日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
#去除表的前缀
mybatis-plus.global-config.db-config.table-prefix=xh_

#Redis配置
spring.redis.port=6379
spring.redis.host=192.168.153.132
spring.redis.timeout=5000
```

### (2).跨域配置

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        //跨域配置，不可设置为*，不安全, 前后端分离项目，可能域名不一致
        //本地测试 端口不一致 也算跨域
        registry.addMapping("/**").allowedOrigins("http://localhost:8080");
    }
}
```



## 4.启动类

```java
@SpringBootApplication
@MapperScan("com.xh.blog.dao")
public class BlogApplication {
    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class, args);
    }
}
```

## 5.相关包名说明

​	**1.vo:用于接收和返回前端所需要的数据**

​	2.controller:用于接收前端请求

​    3.server：用于处理前端请求

​    4.dao：操作数据库

​	5.util:相关工具类（JWT，MD5，返回给前端的统一JSON格式类等）

​    **6.enum：字典，用于储存相关异常信息的描述**

​    7.config：配置类，配置跨域问题，拦截功能等

​    8.domain：用于储存数据库字段

​    9.handler：用于对异常进行统一的处理

   10.interceptor:对请求进行拦截，验证token的合法性

   11.mapper:相关SQL语句的编写



# 二.数据库搭建

## 1.表结构

### (1).文章标题，作者表

```sql
CREATE TABLE `xh_article`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `comment_counts` int(0) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(0) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(0) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(0) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(0) NULL DEFAULT NULL COMMENT '作者id',
  `body_id` bigint(0) NULL DEFAULT NULL COMMENT '内容id',
  `category_id` int(0) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### (2).文章的内容表

```sql
CREATE TABLE `xh_article_body`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_id` bigint(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### (3).文章的类别表

```sql
CREATE TABLE `xh_category`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### (4).作者信息表

```sql
CREATE TABLE `xh_sys_user`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(0) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(0) NULL DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### (5).文章的标签表

```sql
CREATE TABLE `xh_tag`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### (6).文章的标签和文章连接表

```sql
CREATE TABLE `xh_article_tag`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(0) NOT NULL,
  `tag_id` bigint(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

```

### (7).评论表

```sql
CREATE TABLE `xh_comment`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(0) NOT NULL,
  `article_id` int(0) NOT NULL,
  `author_id` bigint(0) NOT NULL,
  `parent_id` bigint(0) NOT NULL,
  `to_uid` bigint(0) NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```



## 2.相关实体类和dao，mapper的搭建

​		**此处使用mybatis-plus创建dao接口，dao接口需要实现BaseMapper<>接口**



# 三.重要工具类

##  (1).ResultJSON

​	返回给前端的状态码(code)，是否成功(success)，相关信息(msg)，要返回的数据(object或者泛型)

```java
@Data
//Lombok自动生成参数的get/set/toString等方法
@AllArgsConstructor
//Lombok中自动生成一个包含所有字段的构造方法
public class ResultJSON implements Serializable {
    private boolean success;
    private int code;
    private String msg;
    private Object data;
    public ResultJSON() {}
    public static ResultJSON success(Object data){
        return new ResultJSON(true,200,"success",data);
    }
    public static ResultJSON fail(int code,String msg){
        return new ResultJSON(false,code,msg,null);
    }
}
```

## (2).JWTUtils

   使用jwt来实现token的生成和token的验证

   **使用jwt的密钥可以写入配置文件中**

   jwt中payload保存用户的id等可以唯一标识信息，不能保存用户的敏感信息（如密码等）

   验证token时若signature的加密算法，密钥，或时间过期会自动抛出RuntimeException，使用ExceptionHandler来进行统一的异常处理

```java
public class JWTUtils {
    //token的密钥
    private static final String TOKEN_SIGN = "^BX(!C(G&af(0ds8g0@)(@ASV^^!!";
    //token的过期时间（天）
    private static final int TIME = 7;
    private JWTUtils(){}
    /**
     * 生成token
     * @param id 要在token中储存的用户的id
     * @return 生成的token
     */
    public static String getToken(Long id){
        JWTCreator.Builder builder = JWT.create();
        //在payload中存储用户的id
        builder.withClaim("id",id);
        //设置过期时间和sigNature
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE,TIME);
        return builder.withExpiresAt(calendar.getTime()).sign(Algorithm.HMAC256(TOKEN_SIGN));
    }
    /**
     * 核实token是否正确
     * @param token token
     * @return 核实之后的Token对象
     */
    public static DecodedJWT verify(String token){
        return JWT.require(Algorithm.HMAC256(TOKEN_SIGN)).build().verify(token);
    }
}
```

## (3).MD5Utils

​      对用户的密码使用MD5加密算法和盐值进行加密处理

​      盐值可以使用用户的id（如果使用UUID作为用户的id）

```java
public class MD5Util {
    private MD5Util(){}
    public static String getMd5Password(String password, String salt) {
        for (int i = 0; i < 3; i++) {
            password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase();
        }
        return password;
    }
}
```



# 四.使用枚举储存异常信息

## ErrorEnum

使用枚举的好处：1.方便经行查找，相当于一个字典的作用

​							   2.避免在程序中直接输入错误信息，方便对错误信息进行修改	

```java
public enum ErrorEnum {
    PARAMS_ERROR(10001,"参数有误"),
    ACCOUNT_PWD_NOT_EXIST(10002,"用户名或密码不存在"),
    NO_PERMISSION(70001,"无访问权限"),
    SESSION_TIME_OUT(90001,"会话超时"),
    NO_LOGIN(90002,"未登录"),
    TOKEN_ERROR(10003,"token验证失败"),
    REGISTER_PARAMS_ERROR(100004,"注册参数错误"),
    ACCOUNT_REPEAT(10005,"用户名重复")
    ;
    private int code;
    private String msg;
    ErrorEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    public int getCode() {
        return code;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public String getMsg() {
        return msg;
    }
    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```



# 五.对全局进行统一异常处理

可以将每一种异常信息详细写出

```java
@ControllerAdvice
//对加了@Controller注解的方法进行拦截处理 aop的实现
public class AllExceptionHandler {
    //进行异常处理
    @ExceptionHandler(Exception.class)
    //将异常消息发送给前端
    @ResponseBody
    public ResultJSON doException(Exception e){
        e.printStackTrace();
        return ResultJSON.fail(-999,"系统异常");
    }
}
```



# 六.首页接口的实现

## 1.实现分页功能

### (1).前端传入的数据和接口

接口url：/articles

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明           |
| -------- | -------- | -------------- |
| page     | int      | 当前页数       |
| pageSize | int      | 每页显示的数量 |

### (2).返回数据

```json
	"success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 1,
            "title": "springboot介绍以及入门案例",
            "summary": "通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。",
            "commentCounts": 2,
            "viewCounts": 54,
            "weight": 1,
            "createDate": "2609-06-26 15:58",
            "author": "12",
            "body": null,
            "tags": [
                {
                    "id": 5,
                    "avatar": null,
                    "tagName": "444"
                },
                {
                    "id": 7,
                    "avatar": null,
                    "tagName": "22"
                },
                {
                    "id": 8,
                    "avatar": null,
                    "tagName": "11"
                }
            ],
            "categorys": null
        }
```

### (3).通过接收的数据和返回的数据创建对应的vo类

#### 	1.创建PageParams接收请求参数

```java
//vo:把某个指定页面或组件的所需要的数据封装
@Data
public class PageParams {
    //当前页数，默认为1
    private int page = 1;
    //一页展示的数量
    private int pageSize = 10;
}
```

#### 	2.创建ArticleVo返回对应的数据

```java
@Data
//vo用于将数据返回给前端，而不和domain中的数据发生冲突
public class ArticleVo {
    private Long id;
    private String title;
    private String summary;
    private Integer commentCounts;
    private Integer viewCounts;
    private Integer weight;
    private String createDate;
    private String author;
    private List<TagVo> tags;
    private List<CategoryVo> categorys;
    private ArticleBodyVo body;
}
```

### (4).使用mybatis提供的分页插件实现分页

#### 	1.配置分页插件

```java
@Configuration
//扫包，将此包下的接口生成代理实现类，并且注册到spring容器中
@MapperScan("com.xh.bolg.dao")
public class MybatisPlusConfig {
    //分页插件
    @Bean
    //这个Bean对象交给Spring管理。
    //产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return interceptor;
    }
}
```

####   	2.使用IPage类来进行分页

```java
IPage<E> iPage = new Page<>(int 当前页数, int 要显示的页数);
//实现分页
QueryWrapper<E> queryWrapper = new QueryWrapper<>();
IPage<E> EIPage = XXXXDao.selectPage(iPage, queryWrapper);
//将实现分页后的Ipage转换为list集合
List<E> EList = EIPage.getRecords();
```

### (5).接收处理请求

controller:@RequestBody注解可以获取请求体中的JSON字符串并且自动将其转换为相对应的对象

```java
    @Resource
    private ArticleService articleService;
    @PostMapping
    //POST请求时
    //@RequestBody --> JSON字符串部分
    //@RequestParam --> 请求参数部分
    public ResultJSON listArticles(@RequestBody PageParams pageParams){
        return articleService.listArticle(pageParams);
    }
```

service:

​		1.需要将实体类对象转换为VO类对象，使用BeanUtils中的copyProperties方法（需要注意若实体类中的数据如果和VO对象中的数据不同，需要转换类型）

​		2.在处理该请求时，需要想到，不是所有的请求都需要tag数据和author数据，所有我们不能一次性将数据全部放入vo对象中，需要进行判断。

​		3.可以在进行转换的时候判断是否需要tag数据和author数据，如果需要，在转换之前先将tag数据查出，然后在放入vo对象中。	

  	 4.先遍历集合，在将集合中的数据进行转换并添加到新的集合中，从而实现集合中所有的数据的转换

```java
 	@Resource
  	private ArticleDao articleDao;
    @Resource
    private TagService tagService;
  	@Resource
    private SysUserService sysUserService;
    @Override
    public ResultJSON listArticle(PageParams pageParams) {
         // 1.分页查询article表实现分页
        IPage<Article> iPage = new Page<>(pageParams.getPage(), pageParams.getPageSize());
        /**
         * 带lambda的wrapper可以使用lambda表达式，选择列，设置列值，反之不带lambda的就需要手动指定列名
         * LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
         * queryWrapper.orderByDesc(Article::getCreateDate);
         */
        QueryWrapper<Article> queryWrapper = new QueryWrapper<>();
        //表的字段名
        //ORDER BY weight DESC,create_date DESC LIMIT ?
        queryWrapper.orderByDesc("weight").orderByDesc("create_date");
        IPage<Article> articleIPage = articleDao.selectPage(iPage, queryWrapper);
        //将分页后的数据转化为list集合
        List<Article> articlesList = articleIPage.getRecords();
        //将domain中的数据转换为vo中的数据交给前端，防止直接与数据库字段进行交互
        //该业务需要tag数据
        List<ArticleVo> articleVoList = copyList(articlesList,true,true);
        return ResultJSON.success(articleVoList);
    }
```

**对实体类对象进行转换:**

​	将List集合中的每一个数据进行转换

```java
    private List<ArticleVo> copyList(List<Article> articlesList, boolean isTag, boolean isAuthor) {
        List<ArticleVo> articleVoList = new ArrayList<>();
        //遍历list集合中的数据，将数据转换为vo类数据
        for(Article record : articlesList){
            articleVoList.add(copy(record,isTag,isAuthor));
        }
        return articleVoList;
    }
```

 对数据进行转换，并且**判断是否需要tag数据和author数据**

若所需要的刚好为实体类数据，则可以不用进行vo的转换

```java
private ArticleVo copy(Article article , boolean isTag, boolean isAuthor){
        ArticleVo articleVo = new ArticleVo();

        /**
         * BeanUtils是由Apache公司所开发的工具包，
         * 目的是为了简化数据封装，方便Java程序员对JavaBean类进行简便的操作。
         * BeanUtils.copyProperties("转换前的类", "转换后的类");
         */
		//若所需要的刚好为实体类数据，则可以不用进行vo的转换
        BeanUtils.copyProperties(article,articleVo);
        //vo中时间存储为String类型，数据库中的事件为Long类型，需要进行转换
        articleVo.setCreateDate(new DateTime(articleVo.getCreateDate()).toString("yyyy-MM-dd HH:mm"));
        //并不是所有的集合都需要标签和作者信息,需要经行判断
        if(isTag){
            Long articleID = article.getId();
            articleVo.setTags(tagService.findTagsByArticleID(articleID));
        }
        if(isAuthor){
            Long authorId = article.getAuthorId();
      articleVo.setAuthor(sysUserService.findSysUserNameByAuthorId(authorId).getNickname());
        }
        return articleVo;
   }
```

**补全所需要的接口方法**

tagService.findTagsByArticleID：

```java
 	@Resource
    private TagDao tagDao;
    @Override
    public List<TagVo> findTagsByArticleID(Long articleID) {
        List<Tag> tagByArticleIdList = tagDao.findTagByArticleId(articleID);
        return copyList(tagByArticleIdList);
    }
```

```xml
#使用子查询先查询出文章的id，在通过文章的id查询某个文章所对应的标签
<select id="findTagByArticleId" resultType="com.xh.blog.domain.Tag">
        select id,avatar,tag_name from xh_tag
        where id
        in
       (select tag_id from xh_article_tag where xh_article_tag.article_id = #{articleID})
    </select>

```

sysUserService.findSysUserNameByAuthorId(authorId):

```java
 	@Resource
    private SysUserDao sysUserDao;	
    @Override
	public SysUser findSysUserNameByAuthorId(Long authorID) {
    	SysUser sysUser = sysUserDao.selectById(authorID);
    	if(sysUser == null){
        	sysUser = new SysUser();
        	sysUser.setNickname("佚名");
    	}
    	return sysUser;
	}
```

## 2.最热标签

### (1).前端传入的数据和接口

| 接口url：/tags/hot |
| :----------------: |
|   请求方式：GET    |
|    请求参数：无    |

### (2).返回的数据

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id":1,
            "tagName":"4444"
        }
    ]
}
```

### (3).接收处理请求

controller:

```java
@RestController
@RequestMapping("/tags")
public class TagController {
    private final static int LIMIT = 6;
    @Resource
    private TagService tagService;
    @GetMapping("/hot")
    public ResultJSON listHotTags(){
        List<TagVo> tagHotList = tagService.hots(LIMIT);
        return ResultJSON.success(tagHotList);
    }
}
```

service:

```java
 @Override
    /** 最热标签：
     * 1.标签所拥有的文章数量最多
     * 2.查询 根据tag_id进行分组技术，从大到小排序
     */
    public List<TagVo> hots(int limit) {
        //若一条sql语句过长，可以将其分开进行查询
        List<Long> tagIdList = tagDao.findTagsHot(limit);
        //List<Tag> tagList = tagDao.selectBatchIds(tagIdList);
        List<Tag> tagList = tagDao.findTagsHotNameById(tagIdList);
        return copyList(tagList);
    }
```

#### 如何查询出最热标签

​	1.每一篇文章出现的标签的总和最多

​	2.在文章和标签的连接表中保存着文章和标签的对应关系，一个文章id对应多个标签id，所有一个先在文章和标签的连接表中**分组查询**出出现标签id数量最多的前几个id

```sql
select tag_id from xh_article_tag group by tag_id order by count(*) desc
```

​	3.通过上述查询出来的文章id，再在tag表中查询标签id所对应的唯一标识和标签名字

```sql
select id, tag_name from xh_tag in (文章的id)
```

​	**4.若sql语句过于复杂，可以将其分为两条sql语句执行**

dao:

```xml
    <select id="findTagsHot"  resultType="java.lang.Long">
        select tag_id from xh_article_tag
        group by tag_id
        order by count(*) desc
        limit #{limit}
    </select>
 	<select id="findTagsHotNameById" resultType="com.xh.blog.domain.Tag">
        select id,avatar,tag_name from xh_tag
        where id in 
        <foreach collection="list" item="tagIdList" open="(" close=")" separator=",">
            #{tagIdList}
        </foreach>
    </select>
```

## 3.最热文章，最新文章，文章归档

### 	(1).接口和返回数据说明

| 最热文章接口           | 最新文章接口           | 文章归档接口                    |
| :--------------------- | :--------------------- | ------------------------------- |
| 接口url：/articles/hot | 接口url：/articles/new | 接口url：/articles/listArchives |
| 请求方式：POST         | 请求方式：POST         | 请求方式：POST                  |
| 请求参数：无           | 请求参数：无           | 请求参数：无                    |

​			返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 1,
            "title": "springboot介绍以及入门案例",
        }]
}
```

文章归档说明:在某年某月所写的文章总数

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "year": "2021",
            "month": "6",
            "count": 2
        }         
    ]
}
```

### 	(2).接收处理请求

controller:

```java
 	//显示最大热门/最新文章数
    private final static int LIMIT = 5;
    @PostMapping("/hot")
    public ResultJSON listHotArticle(){
        return articleService.hotArticles(LIMIT);
    }

    @PostMapping("/new")
    public ResultJSON newArticle(){
        return articleService.newArticles(LIMIT);
    }

    @PostMapping("/listArchives")
    private ResultJSON archives(){
        return articleService.archives();
    }
```

service:

```java
@Override
    public ResultJSON hotArticles(int limit) {
        QueryWrapper<Article> queryWrapper = new QueryWrapper<>();
        //不要忘记limit中的空格
        queryWrapper.select("id","title").orderByDesc("view_counts").last("limit " + limit);
        List<Article> articleList = articleDao.selectList(queryWrapper);
        List<ArticleVo> hotArticleVoList = copyList(articleList,false,false);
        return ResultJSON.success(hotArticleVoList);
    }
    @Override
    public ResultJSON newArticles(int limit) {
        QueryWrapper<Article> queryWrapper = new QueryWrapper<>();
        queryWrapper.select("id","title").orderByDesc("create_date").last("limit " + limit);
        List<Article> articleList = articleDao.selectList(queryWrapper);
        List<ArticleVo> newArticleVoList = copyList(articleList, false, false);
        return ResultJSON.success(newArticleVoList);
    }
    @Override
    public ResultJSON archives() {
        List<Archives> archivesList = articleDao.newArchives();
        return ResultJSON.success(archivesList);
    }
```

dao:

```xml
<select id="newArchives" resultType="com.xh.blog.vo.Archives">
        select year(create_date) as year,month(create_date) as month,count(*) as count
        from xh_article
        group by year,month
    </select>
```



# 七.登录/注册接口

## 	1.登录接口

​		1.登录使用jwt技术，生成token并且保存用户的id信息返回给前端，当用户登录成功后，发放给客户端。**请求需要登录的资源或者接口的时候**，将token携带，后端验证token是否合法。

​		2.将token存入redis中，以token为key，用户的名称，头像，id，账户为key储存在redis中，**作为一次缓存和二次后台token验证**：

​		缓存：当前端通过传入token到后台，后端通过token中保存的id来进行查询用户的相关信息，若在登录返回token时直接将用户的数据传入redis中，就可以直接通过token找到用户所需的id，避免了二次查询mysql数据库

​		二次验证：第一次验证为验证token的正确性，第二次验证时验证redis中是否存有相关数据

### (1).接口说明

接口url：/login

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
```

### (2).接收处理请求

controller:

```java
	@Resource
    private LoginService loginService;
    @PostMapping("/login")
    public ResultJSON login(@RequestBody LoginParams loginParams){
        return loginService.login(loginParams);
    }
```

service:

```java
	//密码MD5加密盐
	private final static String SALT = "SAIAWVABGIUAWGASG";
    @Resource
    private SysUserService sysUserService;
    @Resource
    private RedisTemplate<String,String> redisTemplate;
    @Override
    public ResultJSON login(LoginParams loginParams) {
        //1.检测参数是否合法
        String account = loginParams.getAccount().trim();
        String password = loginParams.getPassword().trim();
        if(StringUtils.isBlank(account) || StringUtils.isBlank(password)){
            return ResultJSON.fail(ErrorEnum.PARAMS_ERROR.getCode(),ErrorEnum.PARAMS_ERROR.getMsg());
        }
        //对密码进行加密
        String encryptedPassword = MD5Util.getMd5Password(password,SALT);
        //2.根据用户名和密码在user表中查询是否存在
        SysUser sysUser = sysUserService.findUser(account,encryptedPassword);
        //3.如果不存在就登录失败
        if(sysUser == null){
            return ResultJSON.fail(ErrorEnum.ACCOUNT_PWD_NOT_EXIST.getCode(),ErrorEnum.ACCOUNT_PWD_NOT_EXIST.getMsg());
        }
        //4.登录成功。使用jwt生成token返回给前端
        String token = JWTUtils.getToken(sysUser.getId());
        //5.将token放入redis当中 token:user 过期时间
        redisTemplate.opsForValue()
                .set("token_"+token,new Gson().toJson(sysUser),1,TimeUnit.DAYS);
        //（进行了一次缓存，使下一次登录不需要在查询一次数据库）
        return ResultJSON.success(token);
    }
```

```java
    @Override
    public SysUser findUser(String account, String encryptedPassword) {
        QueryWrapper<SysUser> wrapper = new QueryWrapper<>();
        wrapper.eq("account",account);
        wrapper.eq("password",encryptedPassword);
        wrapper.select("id","account","avatar","nickname");
        wrapper.last("limit 1");
        return sysUserDao.selectOne(wrapper);
    }
```

## 2.获取用户信息

用户登录成功后将token再次传给后端，后端通过对token的验证来获取redis中保存的用户信息

### 	(1).使用拦截器对请求信息进行拦截，验证token信息

```java
@Component
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        //需要判断 请求的接口路径 是否为 HandlerMethod (controller方法)
        if(!(handler instanceof HandlerMethod)){
            return true;
        }
        String token = request.getHeader("Authorization");

        log.info("=================request start===========================");
        String requestURI = request.getRequestURI();
        log.info("request uri:{}",requestURI);
        log.info("request method:{}",request.getMethod());
        log.info("token:{}", token);
        log.info("=================request end===========================");

        if(StringUtils.isBlank(token)){
            result(response);
            return false;
        }
        try {
            JWTUtils.verify(token);
        }catch (RuntimeException e){
            result(response);
            return false;
        }
        return true;
    }
    private void result(HttpServletResponse response) throws IOException {
        ResultJSON fail = ResultJSON.fail(ErrorEnum.TOKEN_ERROR.getCode(), ErrorEnum.TOKEN_ERROR.getMsg());
        response.setContentType("application/json;charset=utf-8");
        response.getWriter().println(new Gson().toJson(fail));
    }
```

### (2).拦截器的配置

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Resource
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {

       String[] pathPatterns = {
                "/users/**","/logout"
        };
        registry.addInterceptor(loginInterceptor)
                //拦截的路径
                .addPathPatterns(pathPatterns);
    }
}
```

### (3).接口说明

接口url：/users/currentUser

请求方式：GET

请求参数：

| 参数名称      | 参数类型 | 说明            |
| ------------- | -------- | --------------- |
| Authorization | string   | 头部信息(TOKEN) |

返回参数：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": {
        "id":1,
        "account":"1",
        "nickaname":"1",
        "avatar":"ss"
    }
}
```

### (4).接收处理请求

controller:

```java
@RestController
@RequestMapping("/users")
public class UsersController {
    @Resource
    private SysUserService sysUserService;
    @GetMapping("/currentUser")
    public ResultJSON currentUser(@RequestHeader("Authorization") String token){
        return sysUserService.findUserInfoByToken(token);
    }
}

```

service:

```java
 @Override
    public ResultJSON findUserInfoByToken(String token) {
        String JSON = redisTemplate.opsForValue().get("token_" + token);
        SysUserVo sysUserVo = new Gson().fromJson(JSON, SysUserVo.class);
        return ResultJSON.success(sysUserVo);
    }
```

## 3.退出登录

将redis中的数据删除

### (1).接口说明

接口url：/logout

请求方式：GET

请求参数：

| 参数名称      | 参数类型 | 说明            |
| ------------- | -------- | --------------- |
| Authorization | string   | 头部信息(TOKEN) |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": null
}
```

### (2).接收请求参数

controller:

```java
   @GetMapping("/logout")
    public ResultJSON logout(@RequestHeader("Authorization") String token){
        return loginService.logout(token);
    }
```

service:

```java
@Override
    public ResultJSON logout(String token) {
        redisTemplate.delete("token_"+token);
        return ResultJSON.success(null);
    }
```

## 4.注册接口

注册要求：

​	1.验证参数的合法性

​	2.验证有用户名是否重复

​	3.对密码进行加密

​    4.注册用于并且补全数据库中的相关消息

​    5.将数据生成token并且存入reids中，以便注册后直接登录

### (1).接口说明

接口url：/register

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |
| nickname | string   | 昵称 |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
```

### (2).接收处理请求

controller：

```java
	private static final String SALT = "SAIAWVABGIUAWGASG";
    @Resource
    private SysUserDao sysUserDao;
    @Resource
    private RedisTemplate<String,String> redisTemplate;
    @Override
    public ResultJSON register(RegisterParams registerParams) {
        //1.判断参数的合法性
        String account = registerParams.getAccount().trim();
        String password = registerParams.getPassword().trim();
        String nickname = registerParams.getNickname().trim();
        if(StringUtils.isBlank(account) || StringUtils.isBlank(password) || StringUtils.isBlank(nickname)){
           return ResultJSON.fail               (ErrorEnum.REGISTER_PARAMS_ERROR.getCode(),ErrorEnum.REGISTER_PARAMS_ERROR.getMsg());
        }
        //2.判断用户名是否重复
        QueryWrapper<SysUser> wrapper = new QueryWrapper<>();
        wrapper.eq("account",account);
        wrapper.last("limit 1");
        SysUser sysUser = sysUserDao.selectOne(wrapper);
        if(sysUser != null){ return ResultJSON.fail(ErrorEnum.ACCOUNT_REPEAT.getCode(),ErrorEnum.ACCOUNT_PWD_NOT_EXIST.getMsg());
        }
        //3.对密码经行加盐
        String encryptedPassword = MD5Util.getMd5Password(password,SALT);
        //4.注册
        SysUser insertSysUser = new SysUser();
        insertSysUser.setAdmin(true);
        insertSysUser.setDeleted(false);
        insertSysUser.setSalt(SALT);
        insertSysUser.setNickname(nickname);
        insertSysUser.setAccount(account);
        insertSysUser.setPassword(encryptedPassword);
        insertSysUser.setCreateDate(System.currentTimeMillis());
        insertSysUser.setLastLogin(System.currentTimeMillis());
        insertSysUser.setAvatar("/static/img/logo.b3a48c0.png");
        sysUserDao.insert(insertSysUser);
        //5.将数据存储到token和redis中
        String token = JWTUtils.getToken(insertSysUser.getId());
        redisTemplate.opsForValue().set("token_"+token,new Gson().toJson(insertSysUser),1, TimeUnit.DAYS);
        return ResultJSON.success(token);
    }
}
```

## 5.使用ThreadLocal保存用户信息

### 	(1).ThreadLocal工具类

```java
public class ThreadLocalUtils {
    private ThreadLocalUtils(){};
    private static final ThreadLocal<String> LOCAL = new ThreadLocal<>();
    public static void putLocal(String token){
        LOCAL.set(token);
    }
    public static String get(){
        return LOCAL.get();
    }
    //在用户退出登录后，一定要将本地储存的信息删除
    public static void remove(){
        LOCAL.remove();
    }
}
```

### 	(2).在拦截器中保存用户信息

```java
ThreadLocalUtils.putLocal(token);
```

### 	(3).在退出登录时将保存的信息删除

```java
 @Override
    public ResultJSON logout(String token) {
        ThreadLocalUtils.remove();
        redisTemplate.delete("token_"+token);
        return ResultJSON.success(null);
}
```



# 八.文章详情和阅读次数

## 1.文章详情

### (1).接口说明

**使用resul风格接口**

接口url：/articles/view/{id}

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明               |
| -------- | -------- | ------------------ |
| id       | long     | 文章id（路径参数） |

返回数据：

```java
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": {
        "id": 1,
        "title": "springboot介绍以及入门案例",
        "summary": "介绍",
        "commentCounts": 0,
        "viewCounts": 60,
        "weight": 0,
        "createDate": "2609-06-26 15:58",
        "author": "李四",
        "body": {
            "content": "111"
        },
        "tags": [
            {
                "id": 5,
                "tagName": "springboot"
            },
            {
                "id": 7,
                "tagName": "springmvc"
            },
            {
                "id": 8,
                "tagName": "11"
            }
        ],
        "category": {
            "id": 2,
            "avatar": "/category/back.png",
            "categoryName": "后端"
        }
    }
}
```

涉及到的表：文章表，文章内容表，作者表，文章标签表，标签表

### (2).接收处理请求

controller:

**@PathVariable**用于接收result风格的参数

```java
 @PostMapping("/view/{id}")
    public ResultJSON view(@PathVariable("id") Long id){
        return articleService.findArticleById(id);
    }
```

service:

```java
@Override
public ResultJSON findArticleById(Long id) {
    Article article = articleDao.selectById(id);
    //对以前的copy方法做相对应的扩充处理，可以用重载处理
    ArticleVo articleVo = copy(article,true,true,true,true);
    return ResultJSON.success(articleVo);
}
//以下代码对数据库的操作应该放在对应的service中进行,不应该直接写在文章的service中
if(isArticleBody){
ArticleBodyVo articleBodyVo = new ArticleBodyVo();
QueryWrapper<ArticleBody> wrapper = new QueryWrapper<>();
wrapper.select("content").eq("article_id",article.getId());
ArticleBody articleBody = articleBodyDao.selectOne(wrapper);
BeanUtils.copyProperties(articleBody,articleBodyVo);
articleVo.setBody(articleBodyVo);
}
if(isCategory){
QueryWrapper<Category> queryWrapper = new QueryWrapper<>();
queryWrapper.select("id","avatar","category_name").eq("id",article.getCategoryId());
List<Category> categories = categoryDao.selectList(queryWrapper);
articleVo.setCategorys(categories);
}
```

## 2.更新阅读次数

当点击文章后，应该在文章详情对应的方法中直接更新阅读次数，但这个时候做了一个数据库的更新操作，**更新时 加写锁，阻塞其它的读操作**，性能就会降低。

更新增加了此处接口的耗时，如果更新出现问题，不能影响查看文章的操作。

可以**使用线程池**解决这个问题，将更新操作仍到其它线程中去执行，不影响主线程。

### (1).线程池的配置

```java
@Configuration
@EnableAsync//开启多线程
public class ThreadPoolConfig {
    @Bean("taskExecutor")
    public Executor asyncServiceExecutor(){
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 设置核心线程数
        executor.setCorePoolSize(5);
        // 设置最大线程数
        executor.setMaxPoolSize(20);
        //配置队列大小
        executor.setQueueCapacity(Integer.MAX_VALUE);
        // 设置线程活跃时间（秒）
        executor.setKeepAliveSeconds(60);
        // 设置默认线程名称
        executor.setThreadNamePrefix("博客项目");
        // 等待所有任务结束后再关闭线程池
        executor.setWaitForTasksToCompleteOnShutdown(true);
        //执行初始化
        executor.initialize();
        return executor;
    }
}
```

### (2).线程池的使用

```java
@Override
    public ResultJSON findArticleById(Long id) {
        Article article = articleDao.selectById(id);
        ArticleVo articleVo = copy(article,true,true,true,true);
        //将更新操作放入其它线程中执行
        threadService.updateArticleViewCount(articleDao,article);
        return ResultJSON.success(articleVo);
    }
```



```java
@Component
public class ThreadService {
    //希望在此处开启线程池执行，不会影响原有的主线程
    @Async("taskExecutor")
    public void updateArticleViewCount(ArticleDao articleDao, Article article){
        Integer viewCounts = article.getViewCounts();
        //创建一个新的对象，使更新的数据最少
        Article updateArticleViewCount = new Article();
        updateArticleViewCount.setViewCounts(viewCounts+1);
        UpdateWrapper<Article> articleUpdateWrapper = new UpdateWrapper<>();
        articleUpdateWrapper.eq("id",article.getId());
        //在设置一个，为了保证在多线程的情况下线程安全
        //防止进行错误的更新，加两个判断条件
        articleUpdateWrapper.eq("view_counts",viewCounts);
        //sql: update xh_article set view_counts = 100 where id = ? and view_counts = 99
        articleDao.update(updateArticleViewCount,articleUpdateWrapper);
        //测试时睡眠该方法5秒，不会影响主线程的使用
//        try {
//            Thread.sleep(5000);
//        }catch (InterruptedException e){
//            e.printStackTrace();
//        }
    }
}
```



# 九.评论

## 	(1).显示评论列表

1.评论列表分为两个等级，等级level 1 为主评论，等级 level 2 为主评论下面的评论

2.level为2的评论的parent_id为等级level 2的id

### 1.接口说明

接口url：/comments/article/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明               |
| -------- | -------- | ------------------ |
| id       | long     | 文章id（路径参数） |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 53,
            "author": {
                "nickname": "李四",
                "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                "id": 1
            },
            "content": "写的好",
            "childrens": [
                {
                    "id": 54,
                    "author": {
                        "nickname": "李四",
                        "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                        "id": 1
                    },
                    "content": "111",
                    "childrens": [],
                    "createDate": "1973-11-26 08:52",
                    "level": 2,
                    "toUser": {
                        "nickname": "李四",
                        "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                        "id": 1
                    }
                }
            ],
            "createDate": "1973-11-27 09:53",
            "level": 1,
            "toUser": null
        }
    ]
}
```

### 2.根据json创建vo类

```java
@Data
public class CommentVo implements Serializable {
    private Long id;
    private UserVo author;
    private String content;
    private List<CommentVo> childrens;
    private String createDate;
    private Integer level;
    private UserVo toUser;
}
```

```java
@Data
public class UserVo {
    private String nickname;
    private String avatar;
    private Long id;
}
```

### 3.接收处理请求

controller

```java
@RestController
@RequestMapping("/comments")
public class CommentController {
    @Resource
    private CommentService commentService;
    @GetMapping("/article/{id}")
    public ResultJSON article(@PathVariable("id") String id){
        return commentService.findCommentsById(id);
    }
}
```

service:

1.首先从comment表中通过文章的id查询评论等级为1的主评论相关信息

2.将查询出来的信息转换为相应的VO类对象，在copy方法中完成VO类对象的补全

3.在copy方法中查询评论等级为1的用户的相关信息，并将其转换为VO对象

4.在copy方法中通过主评论中的parent_id属性，查询子评论的相关消息以及评论等级为2的用户的相关信息，并且将其转换为对应的VO类

5.无论是评论等级1还是评论等级2都需要递归调用copyList方法和copy方法，所以在copy方法中一定要设置递归的结束条件。

6.在copy中，只有评论等级为1的才会去查询子评论信息，只有评论等级为2的才会去查询被评论用户的相关信息

```java
@Service
public class CommentServiceImpl implements CommentService {
    @Resource
    private CommentDao commentDao;
    @Resource
    private SysUserService sysUserService;
    @Override
    public ResultJSON findCommentsById(String id) {
        //1.根据文章id查询评论列表 从comment表中查询
        //2.通过comment表中的作者id查询作者的信息
        //3.判断level=1 要去查询它有没有子评论
        //4.如果有 根据parent_id进行查询
        QueryWrapper<Comment> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("article_id",id);
        //等级为1的是主评论
        queryWrapper.eq("level",1);
        List<Comment> commentList = commentDao.selectList(queryWrapper);
        List<CommentVo> commentVoList = copyList(commentList);
        return ResultJSON.success(commentVoList);
    }

    private List<CommentVo> copyList(List<Comment> commentList) {
        List<CommentVo> commentVoList = new ArrayList<>();
        for (Comment comment : commentList){
            commentVoList.add(copy(comment));
        }
        return commentVoList;
    }

    private CommentVo copy(Comment comment) {
        CommentVo commentVo = new CommentVo();
        BeanUtils.copyProperties(comment,commentVo);
        //将时间从long转换为String
        commentVo.setCreateDate(new DateTime(comment.getCreateDate()).toString("yyyy-MM-dd HH:mm"));
        //作者信息
        UserVo userVo = sysUserService.findUserVoByAuthorId(comment.getAuthorId());
        commentVo.setAuthor(userVo);
        //子评论 level == 1 时有子评论,通过parentID查询子评论
        //level == 2 没有子评论
        String level = comment.getLevel();
        if("1".equals(level)){
            Long id = comment.getId();
            //找与主评论有相同id的parent_id查询子评论
            List<CommentVo> commentVoList = findCommentsByParentId(id);
            commentVo.setChildrens(commentVoList);
        }
        //to User 查询子评论是给谁评论的
        if("2".equals(level)){
            Long id = comment.getToUid();
            UserVo userVoByToUid = sysUserService.findUserVoByAuthorId(id);
            commentVo.setToUser(userVoByToUid);
        }
        return commentVo;
    }

    private List<CommentVo> findCommentsByParentId(Long id) {
        QueryWrapper<Comment> commentQueryWrapper = new QueryWrapper<>();
        //查询子评论 当level == 2时没有子评论----子评论的等级都是2
        commentQueryWrapper.eq("parent_id",id).eq("level",2);
        List<Comment> comments = commentDao.selectList(commentQueryWrapper);
        //递归查询 子评论的等级只能为2，所以不会无限查询下去
        return copyList(comments);
    }
}
```

## (2).写评论

### 	1.接口说明

接口url：/comments/create/change

请求方式：POST

请求参数：

| 参数名称  | 参数类型 | 说明           |
| --------- | -------- | -------------- |
| articleId | long     | 文章id         |
| content   | string   | 评论内容       |
| parent    | long     | 父评论id       |
| toUserId  | long     | 被评论的用户id |

返回数据:

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": null
}
```

### 2.根据json创建vo类

```java
@Data
public class CommentParams {
    private Long articleId;
    private String content;
    private Long parent;
    private Long toUserId;
}
```

### 3.在拦截器中验证token信息

```java
 @Override
    public void addInterceptors(InterceptorRegistry registry) {
        String[] pathPatterns = {
                "/users/**","/logout","/comments/create/change"
        };
        registry.addInterceptor(loginInterceptor)
                //拦截的路径
                .addPathPatterns(pathPatterns);
    }
```

### 4.接收处理请求

controller:

```java
	@PostMapping("/create/change")
    public ResultJSON comment(@RequestBody CommentParams commentParams){
        return commentService.insertComment(commentParams);
    }
```

service:

从本地线程中获取用户的信息

```java
@Override
    public ResultJSON insertComment(CommentParams commentParams) {
        Long parent = commentParams.getParent();
        Long toUserId = commentParams.getToUserId();
        //从本地获取用户的信息
        String token = ThreadLocalUtils.get();
        //从redis中获取用户的信息
        String s = redisTemplate.opsForValue().get("token_" + token);
        SysUser sysUser = new Gson().fromJson(s, SysUser.class);
        Comment comment = new Comment();
        comment.setCreateDate(System.currentTimeMillis());
        comment.setContent(commentParams.getContent().trim());
        comment.setArticleId(commentParams.getArticleId());
        comment.setAuthorId(sysUser.getId());
        if(parent == null || parent ==0){
            comment.setLevel("1");
        }else {
            comment.setLevel("2");
        }
        comment.setParentId(parent==null ? 0 : parent);
        comment.setToUid(toUserId==null ? 0 : toUserId);
        int insert = commentDao.insert(comment);
        if(insert!=1){
            return ResultJSON.fail(ErrorEnum.COMMENT_ERROR.getCode(),ErrorEnum.COMMENT_ERROR.getMsg());
        }
        return ResultJSON.success(null);
    }
```

### 5.防止前端精度损失

```java
	//防止前端精度损失 把id转为string
    //分布式id比较长，传到前端会有精度损失，必须转为string类型 进行传输，就不会有问题了
    @JsonSerialize(using = ToStringSerializer.class)
    private Long id;
```

# 十.写文章

## (1).所有文章分类

### 1.接口说明

接口url：/categorys

请求方式：GET

请求参数：无

返回数据:

```json
{
    "success":true,
 	"code":200,
    "msg":"success",
    "data":
    [
        {"id":1,"avatar":"/category/front.png","categoryName":"前端"},	
        {"id":2,"avatar":"/category/back.png","categoryName":"后端"},
        {"id":3,"avatar":"/category/lift.jpg","categoryName":"生活"},
        {"id":4,"avatar":"/category/database.png","categoryName":"数据库"},
        {"id":5,"avatar":"/category/language.png","categoryName":"编程语言"}
    ]
}
```

### 2.接收处理请求

controller:

```java
@RestController
@RequestMapping("/categorys")
public class CategoryController {
    @Resource
    private CategoryService categoryService;
    @GetMapping()
    public ResultJSON categories(){
        return categoryService.findAllCategories();
    }
}
```

service

```java
@Resource
    private CategoryDao categoryDao;
    @Override
    public ResultJSON findAllCategories() {
        QueryWrapper<Category> queryWrapper = new QueryWrapper<>();
        queryWrapper.select("id","avatar","category_name");
        List<Category> categories = categoryDao.selectList(queryWrapper);
        return ResultJSON.success(categories);
    }
```

## (2).所有文章标签

### 1.接口说明

接口url：/tags

请求方式：GET

请求参数：无

返回数据

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 5,
            "tagName": "springboot"
        },
        {
            "id": 6,
            "tagName": "spring"
        },
        {
            "id": 7,
            "tagName": "springmvc"
        },
        {
            "id": 8,
            "tagName": "11"
        }
    ]
}
```

### 2.接收处理请求

controller:

```java
	@GetMapping()
    public ResultJSON allTags(){
        return tagService.findAllTags();
    }
```

service:

```java
	@Override
    public ResultJSON findAllTags() {
        QueryWrapper<Tag> queryWrapper = new QueryWrapper<>();
        queryWrapper.select("id","tag_name");
        List<Tag> tagList = tagDao.selectList(queryWrapper);
        return ResultJSON.success(tagList);
    }
```

## (3).发布文章

### 1.接口说明

接口url：/articles/publish

请求方式：POST

请求参数：

| 参数名称 | 参数类型                                                    | 说明     |
| -------- | ----------------------------------------------------------- | -------- |
| title    | string                                                      | 文章标题 |
| id       | long                                                        | 用户id   |
| body     | object（{content: "ww", contentHtml: "ww↵"}）               | 文章内容 |
| category | {id: 2, avatar: "/category/back.png", categoryName: "后端"} | 文章类别 |
| summary  | string                                                      | 文章概述 |
| tags     | [{id: 5}, {id: 6}]                                          | 文章标签 |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": {"id":12232323}
}
```

### 2.创建VO类

```java
@Data
public class ArticleParams {
    private Long id;
    private String title;
    private ArticleBodyParams body;
    private CategoryVo category;
    private String summary;
    private List<TagVo> tags;
}
```

```java
@Data
public class ArticleBodyParams {
    private String content;
    private String contentHtml;
}
```

```java
@Data
public class TagVo {
    @JsonSerialize(using = ToStringSerializer.class)
    private Long id ;
    private String avatar;
    private String tagName;
}
```

### 3.接收处理请求

controller:

```java
	@PostMapping("/publish")
    public ResultJSON publish(@RequestBody ArticleParams articleParams){
        return articleService.publish(articleParams);
    }
```

service:

```java
	@Override
    @Transactional
    public ResultJSON publish(ArticleParams articleParams) {
        Article article = new Article();
        //从本地线程中获取用户的id信息
        String toke = ThreadLocalUtils.get();
        String s = redisTemplate.opsForValue().get("token_" + toke);
        SysUser sysUser = new Gson().fromJson(s, SysUser.class);
        article.setCommentCounts(0);
        article.setCreateDate(System.currentTimeMillis());
        article.setSummary(articleParams.getSummary().trim());
        article.setTitle(articleParams.getTitle().trim());
        article.setViewCounts(0);
        article.setWeight(0);
        article.setAuthorId(sysUser.getId());
        article.setBodyId(-1L);
        article.setCategoryId(articleParams.getCategory().getId());
        articleDao.insert(article);

        //body
        ArticleBody articleBody = new ArticleBody();
        articleBody.setContent(articleParams.getBody().getContent());
        articleBody.setContentHtml(articleParams.getBody().getContentHtml());
        articleBody.setArticleId(article.getId());
        articleBodyDao.insert(articleBody);

        //tags
        List<TagVo> tagVo = articleParams.getTags();
        if(tagVo!=null){
            for (TagVo tagVo1 : tagVo){
                ArticleTag articleTag = new ArticleTag();
                articleTag.setArticleId(article.getId());
                articleTag.setTagId(tagVo1.getId());
                articleTagDao.insert(articleTag);
            }
        }

        Article article1 = new Article();
        article1.setBodyId(articleBody.getId());
        UpdateWrapper<Article> articleUpdateWrapper = new UpdateWrapper<>();
        articleUpdateWrapper.eq("id",article.getId());
        articleDao.update(article1,articleUpdateWrapper);

        ArticleVo articleVo = new ArticleVo();
        articleVo.setId(article.getId());
        return ResultJSON.success(articleVo);
    }
```

## (4).使用aop来记录日志

### 1.使用自定义注解作为切点

使用自定义注解:

```java
@PostMapping("/publish")
    //加上此注解，代表要对此接口记录日志
    @LogAnnotation(module = "文章",operator="写文章")
    public ResultJSON publish(@RequestBody ArticleParams articleParams){
        return articleService.publish(articleParams);
    }
```

注解创建：

```java
import java.lang.annotation.*;

@Target({ElementType.TYPE,ElementType.METHOD})
//Target注解：标注“被标注的注解”可以出现在哪些位置上
//type:表示可以放在类上面 method表示可以放在方法上
@Retention(RetentionPolicy.RUNTIME)
//Retention注解：用来“被标注的注解”最终保存在哪里
//RUNTIME 表示保存在class文件中，并且可以被反射机制读取
@Documented
//在自定义注解的时候可以使用@Documented来进行标注，
//如果使用@Documented标注了，在生成javadoc的时候就会把@Documented注解给显示出来。
public @interface LogAnnotation {

    String module() default "";

    String operator() default "";
}
```

### 2.创建切面类实现AOP

```java
@Component
@Aspect //切面，定义了通知和切点的关系
@Slf4j
public class LogAspect {

    //切点
    @Pointcut("@annotation(com.xh.blog.commom.aop.LogAnnotation)")
    public void pt(){}

    //通知类 环绕通知
    @Around("pt()")
    //方法的定义要求：
    // 1.公共方法
    // 2.必须有一个返回值，推荐使用Object
    // 3.方法名称自定义
    // 4.方法有参数 ,固定参数：ProceedingJoinPoint接口，继承了JoinPoint
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable{
        long beginTime = System.currentTimeMillis();
        //执行方法
        Object result = joinPoint.proceed();
        //执行时长(毫秒)
        long time = System.currentTimeMillis() - beginTime;
        //保存日志
        recordLog(joinPoint, time);
        return result;
    }
	//spring-boot项目中，是默认采用cglib实现动态代理的
    private void recordLog(ProceedingJoinPoint joinPoint, long time) {
        //joinPoint.getSignature();获取方法的完整定义（返回值，方法全名（形参类型））
        //强制转换为方法签名，获取方法上的注解信息
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);
        log.info("======================log start==================");
        log.info("module:{}",annotation.module());
        log.info("operation:{}",annotation.operator());

        //请求的方法名
        String className = joinPoint.getTarget().getClass().getName();
        String methodName = signature.getName();
        log.info("request method:{}",className + "." + methodName + "()");

        //请求参数
        Object[] args = joinPoint.getArgs();
        String params = new Gson().toJson(args[0]);
        log.info("params:{}",params);

        //获取request
        HttpServletRequest httpServletRequest = HttpContextUtils.getHttpServletRequest();
        //获取ip地址
        String ipAddr = IpUtils.getIpAddr(httpServletRequest);
        log.info("ip:{}",ipAddr);

        log.info("excute time : {} ms",time);
        log.info("=====================log end====================");
    }
}
```

### 3.相关工具类

1.HttpContextUtils

```java
//获取request
public class HttpContextUtils {
    private HttpContextUtils(){};
    public static HttpServletRequest getHttpServletRequest(){
        return ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
    }
}
```

2.IpUtils:使用HttpServletRequest获取ip(百度查询)

```java
/获取IP地址
@Slf4j
public class IpUtils {
    private IpUtils(){}
    private static final String IP_UTILS_FLAG = ",";
    private static final String UNKNOWN = "unknown";
    private static final String LOCALHOST_IP = "0:0:0:0:0:0:0:1";
    private static final String LOCALHOST_IP1 = "127.0.0.1";
    public static String getIpAddr(HttpServletRequest request) {
        String ip = null;
        try {
            //以下两个获取在k8s中，将真实的客户端IP，放到了x-Original-Forwarded-For。而将WAF的回源地址放到了 x-Forwarded-For了。
            ip = request.getHeader("X-Original-Forwarded-For");
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("X-Forwarded-For");
            }
            //获取nginx等代理的ip
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("x-forwarded-for");
            }
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("Proxy-Client-IP");
            }
            if (StringUtils.isEmpty(ip) || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("WL-Proxy-Client-IP");
            }
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_CLIENT_IP");
            }
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_X_FORWARDED_FOR");
            }
            //兼容k8s集群获取ip
            if (StringUtils.isEmpty(ip) || UNKNOWN.equalsIgnoreCase(ip)) {
                ip = request.getRemoteAddr();
                if (LOCALHOST_IP1.equalsIgnoreCase(ip) || LOCALHOST_IP.equalsIgnoreCase(ip)) {
                    //根据网卡取本机配置的IP
                    InetAddress iNet = null;
                    try {
                        iNet = InetAddress.getLocalHost();
                    } catch (UnknownHostException e) {
                        log.error("getClientIp error: ", e);
                    }
                    ip = iNet.getHostAddress();
                }
            }
        } catch (Exception e) {
            log.error("IPUtils ERROR ", e);
        }
        //使用代理，则获取第一个IP地址
        if (!StringUtils.isEmpty(ip) && ip.indexOf(IP_UTILS_FLAG) > 0) {
            ip = ip.substring(0, ip.indexOf(IP_UTILS_FLAG));
        }
        return ip;
    }
}
```

## (5).文章归档bug修复

```sql
<select id="newArchives" resultType="com.xh.blog.vo.Archives">
        select year(create_date) as year,month(create_date) as month,count(*) as count
        from xh_article
        group by year,month
</select>
```

**year,mouth函数针对data类型才能取出年**，月,而在该表中插入数据时我们使用的是毫秒值，所以此函数无法读取出年,月等信息。

使用**FROM_UNIXTIME**可以将毫秒值转换为相对应的时间，在**相应数据后面处于1000在加上标识**

```sql
select FROM_UNIXTIME(create_date/1000,'%Y') as year, 
	   FROM_UNIXTIME(create_date/1000,'%m') as month,count(*) as count 
from xh_article 
group by year,month
```

**若在controller中使用private方法接收请求，无法将service注入**

```java
@PostMapping("/listArchives")
    private ResultJSON archives(){
        //NullPointException
        return articleService.archives();
    }
```

# 十一.图片上传

## (1).接口说明

接口url：/upload

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明           |
| -------- | -------- | -------------- |
| image    | file     | 上传的文件名称 |

返回数据：

```json
{
    "success":true,
 	"code":200,
    "msg":"success",
    "data":"https://static.XXX.com/aa.png"
}
```

## (2).接收处理请求

controller:**使用SpringMVC提供的MultipartFile接口接收图片**

**@RequestParam("image")**注解用与指定接收文件的参数

MultipartFile接口常用的的API见下表：

| 方法                         | 功能描述                                                     |
| ---------------------------- | ------------------------------------------------------------ |
| String getOriginalFilename() | 获取上传文件的原始文件名，即该文件在客户端中的文件名。                                      **可能包含路径信息，也可能只是文件名取决于所使用的浏览器** |
| boolean isEmpty()            | 判断上传的文件是否为空，当没有选择文件就直接上传，或者选中的文件是0字节的空文件时，返回true，否则返回false |
| long getSize()               | 获取上传的文件大小，以字节为单位                             |
| String getContentType()      | 根据所上传的文件的扩展名决定该文件的MIME类型，例如上传.jpg格式的图片，将返回image/jpeg |
| InputStream getInputStream() | 获取上传文件的输入字节流，通常用于自定义读取所上传的文件的过程，该方法与transferTo()方法不可以同时使用 |
| void transferTo(File dest)   | 保存上传的文件，该方法与getInputStream()方法不可以同时使用   |

```java
@RestController
@RequestMapping("/upload")
public class UpLoadController {
    @Resource
    private QINiuYunUtils qiNiuYunUtils;
    @PostMapping()

    public ResultJSON upload(@RequestParam("image") MultipartFile multipartFile){
        //MultipartFile接口是由springMVC提供的一个接口，为我们包装了获取文件类型的数据
        //可以用来接受任何类型的文件

        //获取文件的原始文件名称
        //不同浏览器获取的文件名可能不同：
        //可能包含路径信息，也可能只是文件名取决于所使用的浏览器。
        String originalFilename = multipartFile.getOriginalFilename();

        //在上传文件时不能使用原始文件名称，避免重复
        String fileName =
                UUID.randomUUID().toString() + "." +
                        //获取文件的后缀名
                        StringUtils.substringAfterLast(originalFilename,".");
        //将图片上传到七牛云服务器中
        //一般采用字节流上传
        boolean upload = qiNiuYunUtils.upload(multipartFile, fileName);
        if(upload){
            //返回全路径+文件名
            //注意全路径为http://XXX.XXX.com/XXXXXXXXX.png
            //注意"/"是否正确
            return ResultJSON.success(QINiuYunUtils.URL+fileName);
        }
        return ResultJSON.fail(ErrorEnum.FILE_UPLOAD_ERROR.getCode(), ErrorEnum.FILE_UPLOAD_ERROR.getMsg());
    }
}
```

## (3).使用七牛云服务器保存图片

七牛云服务器的相关配置：

```properties
#配置七牛云密钥和空间名
qiniuyun.accessKey=5R22D1OHWgtx4TaGyT8qDFsxWhkk2HSK2hOiiaIH
qiniuyun.secretKey=zlOgvcUXji04m39phc9kUDTsrVXJJ0ExDShov1QY
qiniuyun.bucket=20220303-xh-blog

#上传文件大小设置
#上传文件总的最大值
spring.servlet.multipart.max-request-size=20MB
#单个文件的最大值
spring.servlet.multipart.max-file-size=2MB
```

工具类配置：使用字节流传输文件

更多使用方式参考七牛云官方SDK文档

```java
@Component
//使用@Component注解来将密钥注入
//使用自定义注入不能将参数设置为静态方法
public class QINiuYunUtils {
    
    //域名 注意在URL最后加“/”方便拼接全路径
    public static final String URL = "http://r86cjajtz.hn-bkt.clouddn.com/";
    
    //...生成上传凭证，然后准备上传
    //accessKey,secretKey来自七牛云的密钥管理
    //将密钥信息放入配置文件中
    @Value("${qiniuyun.accessKey}")
    private String accessKey;
    @Value("${qiniuyun.secretKey}")
    private String secretKey;
    //上传到七牛云的那个空间中
    @Value("${qiniuyun.bucket}")
    private String bucket;
    
    public boolean upload(MultipartFile multipartFile,String fileName) {
        //构造一个带指定 Region 对象的配置类
        //Region.region2()--华南地区--根据地区选择，详情看七牛云官方文档
        Configuration cfg = new Configuration(Region.region2());
        //...其他参数参考类注释
        UploadManager uploadManager = new UploadManager(cfg);
        //如果是Windows情况下，格式是 D:\\qiniu\\test.png
        //String localFilePath = "/home/qiniu/test.png";
        try {
            byte[] uploadBytes = multipartFile.getBytes();
            Auth auth = Auth.create(accessKey, secretKey);
            String upToken = auth.uploadToken(bucket);
            //默认不指定key的情况下，以文件内容的hash值作为文件名
            //String key = null ---- fileName;
            Response response = uploadManager.put(uploadBytes, fileName, upToken);
            //解析上传成功的结果
            DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
            //上传成功返回true
            return true;
        } catch (QiniuException ex) {
            Response r = ex.response;
            try {
                System.err.println(r.bodyString());
            } catch (QiniuException ex2) {
                //ignore
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }
}
```

# 十二.文章分类

## (1).导航-文章分类

### 1.查询所有的文章分类

#### (一).接口说明

接口url：/categorys/detail

请求方式：GET

请求参数：无

返回数据：

```json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": [
        {
            "id": 1, 
            "avatar": "/static/category/front.png", 
            "categoryName": "前端", 
            "description": "前端是什么，大前端"
        }
}
```

#### (二).接收处理请求

 controller:

```java
	@GetMapping("/detail/{id}")
    public ResultJSON detailId(@PathVariable String id){
        return  categoryService.findCategoriesById(id);
    }
```

service:

```java
    @Override
    public ResultJSON findAllCategoriesMsg() {
        //selectList(new QueryWrapper<>() 相当于查询表中所有的信息
        List<Category> categories = categoryDao.selectList(new QueryWrapper<>());
        return ResultJSON.success(categories);
    }
```

### 2.查询所有的标签

#### (一).接口说明

接口url：/tags/detail

请求方式：GET

请求参数：无

返回数据:

```json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": [
        {
            "id": 5, 
            "tagName": "springboot", 
            "avatar": "/static/tag/java.png"
        }
}
```

#### (二).接收处理请求

controller:

```java
    @GetMapping("/detail")
    public ResultJSON findDetail(){
        return tagService.findDetail();
    }
```

service:

```java
    @Override
    public ResultJSON findDetail() {
        List<Tag> tagList = tagDao.selectList(new QueryWrapper<>());
        return ResultJSON.success(tagList);
    }
```

## (2).分类文章列表

### 1.接口说明

接口url：/category/detail/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明     |
| -------- | -------- | -------- |
| id       | 分类id   | 路径参数 |

返回数据：

```json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": 
        {
            "id": 1, 
            "avatar": "/static/category/front.png", 
            "categoryName": "前端", 
            "description": "前端是什么，大前端"
        }
}
```

### 2.接收处理请求

controller:

```java
  	@GetMapping("/detail/{id}")
    public ResultJSON detailId(@PathVariable String id){
        return  categoryService.findCategoriesById(id);
    }
```

service:

```java
  	@Override
    public ResultJSON findCategoriesById(String id) {
        Category category = categoryDao.selectById(id);
        return ResultJSON.success(category);
    }
```

## (3).标签文章列表

### 1.接口说明

接口url：/tags/detail/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明     |
| -------- | -------- | -------- |
| id       | 标签id   | 路径参数 |

返回数据：

```json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": 
        {
            "id": 5, 
            "tagName": "springboot", 
            "avatar": "/static/tag/java.png"
        }
}
```

### 2.接收处理请求

controller:

```java
@GetMapping("/detail/{id}")
public ResultJSON DetailById(@PathVariable("id") String id){
    return tagService.findTagsByID(id);
}
```

service:

```java
@Override
public ResultJSON findTagsByID(String id) {
    Tag tag = tagDao.selectById(id);
    return ResultJSON.success(tag);
}
```

## (4).修改文章列表查询

在查询文章列表的service中进行修改，添加上分类查询的相关条件

### 1.在文章列表查询的vo类中添加相对应的接收参数

```java
@Data
public class PageParams {
    //当前页数，默认为1
    private int page = 1;
    //一页展示的数量
    private int pageSize = 10;
    //新添加数据
    private Long categoryId;
    private Long tagId;
    private String month;
    private String year;
    //如果月只有一位，则在月前加上0 如03
    public String getMonth() {
        if(this.month != null && this.month.length()==1){
            //方便对sql语句进行处理
            return "0"+this.month;
        }
        return month;
    }
}
```

### 2.使用分页＋动态sql实现模糊查询

如何在自定义sql中使用分页插件:

```java
IPage<UserVo> selectPageVo(IPage<?> page, Integer state);
// or (class MyPage extends Ipage<UserVo>{ private Integer state;})
MyPage selectPageVo(M
yPage page);
// or
List<UserVo> selectPageVo(IPage<UserVo> page, Integer state);
```

```xml
<select id="selectPageVo" resultType="xxx.xxx.xxx.UserVo">
    <!--分页参数无需进行赋值-->
    SELECT id,name FROM user WHERE state=#{state}
</select>
```

```java
//使用分页插件+自定义动态sql修改查询文章列表
@Override
public ResultJSON listArticle(PageParams pageParams){
    Page<Article> page = new Page<>(pageParams.getPage(), pageParams.getPageSize());
    IPage<Article> iPage = articleDao.findArticles(
            page,
            pageParams.getCategoryId(),
            pageParams.getTagId(),
            pageParams.getYear(),
            pageParams.getMonth());
    //将分页查询后的数据转换为lsit集
    List<Article> records = iPage.getRecords();
    return ResultJSON.success(copyList(records,true,true));
}
```

### 3.动态sql

为什么使用动态sql：

在mybatis-plus中没有与from_unixtime相关的函数，需要使用原生的mybatis

```xml
<!-- Long categoryId, Long tagId, String year, String month-->
<select id="findArticles" resultMap="BaseResultMap">
    select * from xh_article
    <where>
        <if test="categoryId != null">
            category_id = #{categoryId}
        </if>
        <if test="tagId != null">
            and id in (select article_id from xh_article_tag where tag_id = #{tagId})
        </if>
        <!--
            在动态sql中，用and进行条件的连接
            在mybatis-plus中没有与from_unixtime相关的函数
            需要使用原生的mybatis
        -->
        <if test="year != null and year.length>0 and month !=null and month.length>0">
            and (from_unixtime(create_date/1000,'%Y') = #{year}
                  and from_unixtime(create_date/1000,'%m') = #{month})
        </if>
    </where>
    order by weight,create_date Desc
</select>
```

# 十三.统一缓存优化

## (1).使用aop经行缓存优化

内存的访问速度远远大于磁盘的访问速度 快1000倍左右

### 1.使用自定义注解作为切点

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Cache {
    //设置过期时间 默认为1分钟
    long expire() default 60 * 1000;
    //缓存标识
    String name() default "";
}
```

### 2.使用aop

```java
@Aspect
@Component
@Slf4j
public class CacheAspect {

    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    @Pointcut("@annotation(com.xh.blog.commom.cache.Cache)")
    public void pt(){}

    @Around("pt()")
    //使用缓存的标识+类名+方法名+参数类型MD5加密后的字符串作为redis的key
    public Object cache(ProceedingJoinPoint pjp) throws Throwable{
        //获取方法的完整定义
        Signature signature = pjp.getSignature();
        //获取类名
        String className = pjp.getTarget().getClass().getSimpleName();
        //获取调用的方法名
        String methodName = signature.getName();

        //获取方法的参数类型
        Object[] args = pjp.getArgs();
        StringBuffer params = new StringBuffer();
        for (int i=0;i<args.length;i++){
            //将方法的参数类型转换为JSON字符串
            if(args[i] != null){
                params.append(new Gson().toJson(args[i]));
                //将参数的类型放入数组中储存
            }
        }
        String MD5Params = "";
        if(StringUtils.isNoneBlank(params)){
            //加密，防止出现key过长以及字符转义获取不到的情况
            MD5Params = DigestUtils.md5Hex(String.valueOf(params));
        }

        //获取方法操作对象
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();
        //获取Cache注解
        Cache annotation = method.getAnnotation(Cache.class);
        //获取缓存的过期时间
        long expire = annotation.expire();
        //获取缓存的标识
        String name = annotation.name();

        //先从redis中获取
        String redisKey = name + "::" + className + "::" + methodName + "::" +MD5Params;
        String redisValue = redisTemplate.opsForValue().get(redisKey);
        if(StringUtils.isNoneEmpty(redisKey)){
            log.info("走了缓存~~~~~~~~~~,{},{}",className,methodName);
            return new Gson().fromJson(redisValue, ResultJSON.class);
        }

        //如果redis没有缓存，则设置缓存
        //先执行目标方法，得到返回的对象
        Object proceed = pjp.proceed();
        redisTemplate.opsForValue().set(redisKey,new Gson().toJson(proceed), Duration.ofMillis(expire));
        log.info("存入缓存~~~~~~~~~~,{},{}",className,methodName);
        return proceed;
    }
}
```

